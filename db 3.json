{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/avatar.jpg","path":"avatar.jpg","modified":1,"renderable":0},{"_id":"source/avatar_small.jpg","path":"avatar_small.jpg","modified":1,"renderable":0},{"_id":"source/favicon.jpg","path":"favicon.jpg","modified":1,"renderable":0},{"_id":"source/uploads/AES是个什么鬼？/AES-AddRoundKey.png","path":"uploads/AES是个什么鬼？/AES-AddRoundKey.png","modified":1,"renderable":0},{"_id":"source/uploads/AES是个什么鬼？/AES-MixColumns.png","path":"uploads/AES是个什么鬼？/AES-MixColumns.png","modified":1,"renderable":0},{"_id":"source/uploads/AES是个什么鬼？/AES-SubBytes.png","path":"uploads/AES是个什么鬼？/AES-SubBytes.png","modified":1,"renderable":0},{"_id":"source/uploads/AES是个什么鬼？/AES-ShiftRows.png","path":"uploads/AES是个什么鬼？/AES-ShiftRows.png","modified":1,"renderable":0},{"_id":"source/uploads/AES是个什么鬼？/S-box-DES-input011011.png","path":"uploads/AES是个什么鬼？/S-box-DES-input011011.png","modified":1,"renderable":0},{"_id":"source/uploads/AES是个什么鬼？/des-encrypt.png","path":"uploads/AES是个什么鬼？/des-encrypt.png","modified":1,"renderable":0},{"_id":"source/uploads/Use-Swift-framework-in-OC-project/bridging-header.png","path":"uploads/Use-Swift-framework-in-OC-project/bridging-header.png","modified":1,"renderable":0},{"_id":"source/uploads/easy-core-data/choose_entity.png","path":"uploads/easy-core-data/choose_entity.png","modified":1,"renderable":0},{"_id":"source/uploads/easy-core-data/attributes.png","path":"uploads/easy-core-data/attributes.png","modified":1,"renderable":0},{"_id":"source/uploads/easy-core-data/model_document.png","path":"uploads/easy-core-data/model_document.png","modified":1,"renderable":0},{"_id":"source/uploads/easy-core-data/main_vc.png","path":"uploads/easy-core-data/main_vc.png","modified":1,"renderable":0},{"_id":"source/uploads/easy-core-data/choose_model.png","path":"uploads/easy-core-data/choose_model.png","modified":1,"renderable":0},{"_id":"source/uploads/easy-core-data/r_u_kidding.png","path":"uploads/easy-core-data/r_u_kidding.png","modified":1,"renderable":0},{"_id":"source/uploads/easy-core-data/result.png","path":"uploads/easy-core-data/result.png","modified":1,"renderable":0},{"_id":"source/uploads/easy-core-data/use_core_data.png","path":"uploads/easy-core-data/use_core_data.png","modified":1,"renderable":0},{"_id":"source/uploads/push-notification-preparation/push-on.jpg","path":"uploads/push-notification-preparation/push-on.jpg","modified":1,"renderable":0},{"_id":"source/uploads/push-notification-preparation/push-off.jpg","path":"uploads/push-notification-preparation/push-off.jpg","modified":1,"renderable":0},{"_id":"source/uploads/using-autolayout-in-uitableviewcells/cell-ui.png","path":"uploads/using-autolayout-in-uitableviewcells/cell-ui.png","modified":1,"renderable":0},{"_id":"source/uploads/using-autolayout-in-uitableviewcells/cellForRowAtIndexPath-code.png","path":"uploads/using-autolayout-in-uitableviewcells/cellForRowAtIndexPath-code.png","modified":1,"renderable":0},{"_id":"source/uploads/using-autolayout-in-uitableviewcells/return-height-code.png","path":"uploads/using-autolayout-in-uitableviewcells/return-height-code.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"source/uploads/easy-core-data/accept_challenge.png","path":"uploads/easy-core-data/accept_challenge.png","modified":1,"renderable":0},{"_id":"source/uploads/easy-core-data/persistence_stack.png","path":"uploads/easy-core-data/persistence_stack.png","modified":1,"renderable":0},{"_id":"source/uploads/iOS获取图片附加信息/focus.png","path":"uploads/iOS获取图片附加信息/focus.png","modified":1,"renderable":0},{"_id":"source/uploads/push-notification-preparation/request-csr.jpg","path":"uploads/push-notification-preparation/request-csr.jpg","modified":1,"renderable":0},{"_id":"source/uploads/push-notification-preparation/apple-push-notification.jpg","path":"uploads/push-notification-preparation/apple-push-notification.jpg","modified":1,"renderable":0},{"_id":"source/uploads/using-autolayout-in-uitableviewcells/layoutSubviews-code.png","path":"uploads/using-autolayout-in-uitableviewcells/layoutSubviews-code.png","modified":1,"renderable":0},{"_id":"source/uploads/using-autolayout-in-uitableviewcells/offscreen-cell-code.png","path":"uploads/using-autolayout-in-uitableviewcells/offscreen-cell-code.png","modified":1,"renderable":0},{"_id":"source/uploads/easy-core-data/create_subclasses.png","path":"uploads/easy-core-data/create_subclasses.png","modified":1,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1,"renderable":1},{"_id":"source/uploads/easy-core-data/let_run.png","path":"uploads/easy-core-data/let_run.png","modified":1,"renderable":0},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"fbb0c751ebc8eaa01f4cb7d11032ba0c1a021f42","modified":1465178792000},{"_id":"source/CNAME","hash":"96ff60e7e18edda3bfc692c2edaa2be56e5eb0ea","modified":1461671129000},{"_id":"source/avatar.jpg","hash":"98cec236da453731741005b3e665dc1150208474","modified":1461143804000},{"_id":"source/avatar_small.jpg","hash":"07cad3ea697a1459e74fc2b872766508bfc0b794","modified":1461728085000},{"_id":"source/favicon.jpg","hash":"9f40dbf72d6f87bac28f7199e795bf943748094c","modified":1461631368000},{"_id":"themes/next/.DS_Store","hash":"21be0d83cb62ee8ce50367bde55e7071187670ee","modified":1463021687000},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1459472724000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1459472724000},{"_id":"themes/next/.gitignore","hash":"efec790f5b7a0256763e1cc08f12c4f0aff509f6","modified":1459472724000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1459472724000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1459472724000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1459472724000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1459472724000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1459472724000},{"_id":"themes/next/_config.yml","hash":"f18423ee9e37ba1c20c56b2c8db0d44fb4cad24d","modified":1465179148000},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1459472724000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1459472724000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1459472724000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1465177693000},{"_id":"source/_posts/Use-Swift-framework-in-OC-project.md","hash":"2adfee2452c4d1237ff4f767b380b657f9400af8","modified":1463046456000},{"_id":"source/_posts/about-aes-encryption.md","hash":"e0624ba68a7c6799f9575d1f7feeb8cf1945c244","modified":1462354759000},{"_id":"source/_posts/easy-core-data.md","hash":"bd9dc20cb3b001f9db76d8f9434cc4b0f4194148","modified":1462761570000},{"_id":"source/_posts/get-exif-from-image-ios.md","hash":"6e0f89b0d19469cdae70b8cc991b00efe77465ab","modified":1461662329000},{"_id":"source/_posts/hash-with-salt.md","hash":"4aafef124d818e3860a6f8fb06d0ce9c31dded4e","modified":1461662384000},{"_id":"source/_posts/push-notification-preparation.md","hash":"5d964f4cdf52f441ca331dbdb9ca7c55d8816e38","modified":1465180554000},{"_id":"source/_posts/using-autolayout-in-uitableviewcells.md","hash":"a476f28096a076af21eb4c71ea9154f433932986","modified":1461920087000},{"_id":"source/about/index.md","hash":"6b2d2104cae913f99c5a8bf53b0e5cf9d6c6e252","modified":1463191895000},{"_id":"source/about/.DS_Store","hash":"af5ebac0ae2a7092d1d70e537899bbda514e438e","modified":1465177680000},{"_id":"source/categories/index.md","hash":"b47d26a160990cf4df2041651285f3755ce7831e","modified":1461310358000},{"_id":"source/tags/index.md","hash":"2489300e19056b5be1a4075790dc308acc0110e5","modified":1461310345000},{"_id":"source/uploads/.DS_Store","hash":"455d4f24b39bf8de699ce5f9f211b5315506247e","modified":1465178792000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1459472724000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1459472724000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1459472724000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1459472724000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1459472724000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1459472724000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1459472724000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1459472724000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1459472724000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1459472724000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1459472724000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1459472724000},{"_id":"themes/next/layout/_layout.swig","hash":"993df74467835eeb223d92206f36ecd6cfe5119e","modified":1459472724000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1459472724000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1459472724000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1459472724000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1459472724000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1459472724000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1459472724000},{"_id":"themes/next/scripts/.DS_Store","hash":"869e86bb9da6314a7debf22465af95a329a814f9","modified":1461657606000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1459472724000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1459472724000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1459472724000},{"_id":"themes/next/source/.DS_Store","hash":"c92c72f712414da76a0693c58a75237a227550bf","modified":1462765110000},{"_id":"themes/next/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1459472724000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1459472724000},{"_id":"source/uploads/AES是个什么鬼？/AES-AddRoundKey.png","hash":"599f3590cbfe711e7968a9f9e507c48c8c4e688a","modified":1461567521000},{"_id":"source/uploads/AES是个什么鬼？/AES-MixColumns.png","hash":"95ba6b35ec106f237d37abad8f2f82c6fc4c4644","modified":1461326016000},{"_id":"source/uploads/AES是个什么鬼？/AES-SubBytes.png","hash":"3c5d03fd9d5830738112ad2573acbe991d8ac057","modified":1461326009000},{"_id":"source/uploads/AES是个什么鬼？/AES-ShiftRows.png","hash":"69ec64d9619ebe000719fb5aa77dbb426f620ba1","modified":1461326013000},{"_id":"source/uploads/AES是个什么鬼？/S-box-DES-input011011.png","hash":"041275e5785883253f4eec6f529fd7a3ecfd82e1","modified":1461231307000},{"_id":"source/uploads/AES是个什么鬼？/des-encrypt.png","hash":"36121a53a6e954adac9a444514ec59710d2ebd98","modified":1461032635000},{"_id":"source/uploads/Use-Swift-framework-in-OC-project/bridging-header.png","hash":"a9df6be603e1a063813998f3f67e074bca27c10e","modified":1447490054000},{"_id":"source/uploads/easy-core-data/choose_entity.png","hash":"9a0bc5ae912b3113731bebe1ca9819c09ec51054","modified":1435860612000},{"_id":"source/uploads/easy-core-data/attributes.png","hash":"78eced9feaa92942c14e15c58a457d37e7752eb2","modified":1435860612000},{"_id":"source/uploads/easy-core-data/model_document.png","hash":"42d0bc81d2c362032a949474aad8e3f0baa45c6c","modified":1435860612000},{"_id":"source/uploads/easy-core-data/main_vc.png","hash":"131f28d6768fb998bebae3ed7a6180e7a21bc8e7","modified":1435860612000},{"_id":"source/uploads/easy-core-data/choose_model.png","hash":"9c8e63dac96ca8ab7a5c09bcb20fd248b94cd95b","modified":1435860612000},{"_id":"source/uploads/easy-core-data/r_u_kidding.png","hash":"5324c94acd85480fafb613ba135b5e8ff03e1256","modified":1435860612000},{"_id":"source/uploads/easy-core-data/result.png","hash":"ff5b46f4676f92a1df08ad14880ac2a87a095201","modified":1435860612000},{"_id":"source/uploads/easy-core-data/use_core_data.png","hash":"63b4a7968066f2686d15a71c7d2fc6fb7be0a556","modified":1435860612000},{"_id":"source/uploads/push-notification-preparation/push-on.jpg","hash":"1ba15a67d95a22f9428855ca374a430306d7ed26","modified":1464859145000},{"_id":"source/uploads/push-notification-preparation/push-off.jpg","hash":"95c5d71721d8cb2a63b1d91b1c9fd6b391852d2f","modified":1464858865000},{"_id":"source/uploads/using-autolayout-in-uitableviewcells/cell-ui.png","hash":"e58704a0ae98d47962d71b3c456f70cab58adf5c","modified":1442582401000},{"_id":"source/uploads/using-autolayout-in-uitableviewcells/cellForRowAtIndexPath-code.png","hash":"e2e2eb2ba1c27234903bd07288054ede28b7b0dd","modified":1442582401000},{"_id":"source/uploads/using-autolayout-in-uitableviewcells/return-height-code.png","hash":"fa519cf38b59688e033ec03037421b4be5466b46","modified":1442582401000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1459472724000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1459472724000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1459472724000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"21b055278a74f190571af67cfae03ae6c3fb295c","modified":1459472724000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1459472724000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"70bd1f11a558a7fc4b8fd7860377f31e0357ceb6","modified":1459472724000},{"_id":"themes/next/layout/_macro/post.swig","hash":"379737761f44fb71de997a73192f35b8e568ac58","modified":1459472724000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"22018ebec911eaded925010fc2297859abe447a3","modified":1465287709000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1459472724000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"82a9bc2ba60ce68419128ff60624bd74b15dfb78","modified":1459472724000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c1a10ae0215a4edae3f70930a48cf8543e0b368a","modified":1463021492000},{"_id":"themes/next/layout/_partials/head.swig","hash":"b8c3f594b0a6062764ec666c44762a36312259f1","modified":1461753305000},{"_id":"themes/next/layout/_partials/header.swig","hash":"7739068b69f87ae641dea19c3445169ae80d5df4","modified":1459472724000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1459472724000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1459472724000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1459472724000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1459472724000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1459472724000},{"_id":"themes/next/source/css/.DS_Store","hash":"ea5ff2fe1cba2d68f91cc4372ce29a148637b41a","modified":1462761417000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1459472724000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1459472724000},{"_id":"themes/next/source/images/avatar.jpg","hash":"98cec236da453731741005b3e665dc1150208474","modified":1461143804000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1459472724000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1459472724000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1459472724000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1459472724000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1459472724000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1459472724000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1459472724000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1459472724000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1459472724000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1459472724000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1459472724000},{"_id":"themes/next/source/js/.DS_Store","hash":"b450bd21c6c7f149825ca75dbdcfb90db64b0eb3","modified":1462761468000},{"_id":"themes/next/source/vendors/.DS_Store","hash":"8e7f80bcb5ea6233e4b7a8869695c5053bd3043e","modified":1461657667000},{"_id":"source/uploads/easy-core-data/accept_challenge.png","hash":"fd31a1cac8f81c93025093ff5ef78cb38761d746","modified":1435860612000},{"_id":"source/uploads/easy-core-data/persistence_stack.png","hash":"fb314c7b5c480328986f31da4b609d9d2180ef6d","modified":1435860612000},{"_id":"source/uploads/iOS获取图片附加信息/focus.png","hash":"3cfd0f66a94b820009b97531c4e2d88b68b9fc0c","modified":1435860612000},{"_id":"source/uploads/push-notification-preparation/request-csr.jpg","hash":"3b149e79860c17d2849ff6fc4d7d9ac519ee4f20","modified":1464858769000},{"_id":"source/uploads/push-notification-preparation/apple-push-notification.jpg","hash":"ca05e5422e41b484b23c6ed1580d336796bd1c7e","modified":1464861171000},{"_id":"source/uploads/using-autolayout-in-uitableviewcells/layoutSubviews-code.png","hash":"ff551e0e35345b6d6643eae806d9e4a037e0477b","modified":1442582401000},{"_id":"source/uploads/using-autolayout-in-uitableviewcells/offscreen-cell-code.png","hash":"8ec29fd541c64f71811f85224753ac2c60f2f28e","modified":1442582401000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1459472724000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1459472724000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462764802000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1459472724000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1459472724000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1459472724000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1459472724000},{"_id":"source/uploads/easy-core-data/create_subclasses.png","hash":"23fe661cd9a4918740f63e4c5a7cd210fdd4badb","modified":1435860612000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1459472724000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1459472724000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1459472724000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1459472724000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"2fc4a0d2c825a512f39c0eadd78452e90615465a","modified":1459472724000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"1561bd0c107d725252c6d746e9ac177fc18f93bf","modified":1459472724000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1459472724000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"df03220eb8526e17dc9c9f17780c2d6699367181","modified":1459472724000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1459472724000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1459472724000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1459472724000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1459472724000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1459472724000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1459472724000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1459472724000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1459472724000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1459472724000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"4e49707c99c8bbcfa0a607dfdaff0fbb7dffd2a3","modified":1459472724000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"11a5e4c66c52b2974f90c6ee7d017b5fbee363a5","modified":1461376968000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"11d443fc97648d2965d7f8bad9f4a493996fe62f","modified":1459472724000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"78a8e2e2d6676948f38a9a74e67c5a74e6ae57ff","modified":1461546614000},{"_id":"themes/next/source/css/_variables/default.styl","hash":"8ec3307fe42d738b1bbda4b6419d0995f5560222","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/.DS_Store","hash":"64f84b5f7bafa28aaf28df216a8065acd3aeefa6","modified":1462765116000},{"_id":"themes/next/source/js/src/.DS_Store","hash":"ff28fa714f4ffbc0b02a0147118c8debc3248744","modified":1461657624000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1459472724000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1459472724000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1459472724000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1459472724000},{"_id":"themes/next/source/js/src/post-details.js","hash":"10247c78fe933a0cfcaad22a2a03e7a026864461","modified":1465199197000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1459472724000},{"_id":"themes/next/source/js/src/utils.js","hash":"a3a3375de818964f4cbed4d0e2c2f97ccee7199e","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1459472724000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1459472724000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1459472724000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1459472724000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1459472724000},{"_id":"themes/next/source/vendors/font-awesome/.DS_Store","hash":"470bd5505db2511ad68d79996bef4395e98d21d6","modified":1461657667000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1459472724000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1459472724000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1459472724000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1459472724000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1459472724000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1459472724000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1459472724000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1459472724000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1459472724000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1459472724000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1459472724000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1459472724000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1459472724000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1459472724000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1459472724000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1459472724000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1459472724000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1459472724000},{"_id":"source/uploads/easy-core-data/let_run.png","hash":"5d6c0feead68fb4882ac2cec93a6f25d97e6d9fc","modified":1435860612000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1459472724000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"44e761721e8ad787ef571a3cc57bbc12d318a2a3","modified":1459472724000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"334176d838ee528e58468d8bc74ff3a6d3f25b2b","modified":1459472724000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1459472724000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1459472724000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a613af7826e2757a71f9f29a7eac7b5b510226f7","modified":1463021762000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1459472724000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1462765139000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1459472724000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"4c84903d6a15a903235eec04a560fdeda80c12f3","modified":1459472724000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1459472724000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1459472724000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"04e6c5257814c65e638ab70c53030e8dfdb3f37d","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"8aca5d9f1df157ab27e699c1b3ba9438b9e039ad","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"e40c7d09f435c185dcb23e7c1131dcde32d45830","modified":1461384146000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"31e233f9544df96ecc46e53a9236db727032b367","modified":1462764825000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"6cc10d943d92eac953e6978e46d27ae55584482c","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"9658d09de4fcc809a29d4b706a9621adfb3090ad","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"cd2acd8c415c552e397af2da61d7659688e7aab4","modified":1459472724000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1459472724000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1459472724000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1459472724000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1459472724000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1459472724000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1459472724000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1459472724000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1459472724000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1459472724000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1459472724000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1459472724000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1459472724000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"61763d236029d2a4414be499d0e65d7dfb34605b","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"db5c2093bec1f1642ad0a3702290bf49b4b8ed35","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"23dd966324937deeccc8f5fa16a6d32e4e46243b","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"fe71e9be08cb418cf68352fd6212ddd0d7150579","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1462765145000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"330a2ce52c5a5fefc1e85c473113a3bc58210c76","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"99d994bd19895a4aaa2fa8d12801ec72dd3cf118","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4677ae612ff9c593ee17ab2ea82dbb995432d301","modified":1462764620000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"89fef1caf94caf76ca09c643b83b0b4d4e417e08","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"cbaf1b1740a1bb6075617398dd152dfccd1f09b0","modified":1461384605000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"58fb7604b44e3f56d880bbbd95d0baface38c4ee","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1459472724000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"f7ebd428f3058ec3ecc7648788712617bea520ba","modified":1459472724000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1459472724000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1459472724000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1459472724000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1459472724000}],"Category":[],"Data":[],"Page":[{"title":"分类","date":"2016-04-22T07:28:37.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2016-04-22 15:28:37\ntype: categories\ncomments: false\n---\n","updated":"2016-04-22T07:32:38.000Z","path":"categories/index.html","layout":"page","_id":"cip56hb6g0001gr8fkh38jr9x","content":"","excerpt":"","more":""},{"title":"about","date":"2016-04-22T07:34:17.000Z","type":"about","comments":0,"_content":"<h1><p class=\"text-center\">My name's Lee</p></h1>\n<p class=\"text-center\">iOS程序员一枚，现在居然还在做Android开发。</p>\n<p class=\"text-center\">如果紧跟导师步伐的话，那么下一步就是后台了呀...</p>\n![avatar](/avatar_small.jpg)\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-04-22 15:34:17\ntype: about\ncomments: false\n---\n<h1><p class=\"text-center\">My name's Lee</p></h1>\n<p class=\"text-center\">iOS程序员一枚，现在居然还在做Android开发。</p>\n<p class=\"text-center\">如果紧跟导师步伐的话，那么下一步就是后台了呀...</p>\n![avatar](/avatar_small.jpg)\n","updated":"2016-05-14T02:11:35.000Z","path":"about/index.html","layout":"page","_id":"cip56hb6k0003gr8fvsb5rpew","content":"<h1><p class=\"text-center\">My name's Lee</p></h1>\n<p class=\"text-center\">iOS程序员一枚，现在居然还在做Android开发。</p>\n<p class=\"text-center\">如果紧跟导师步伐的话，那么下一步就是后台了呀...</p>\n![avatar](/avatar_small.jpg)\n","excerpt":"","more":"<h1><p class=\"text-center\">My name's Lee</p></h1>\n<p class=\"text-center\">iOS程序员一枚，现在居然还在做Android开发。</p>\n<p class=\"text-center\">如果紧跟导师步伐的话，那么下一步就是后台了呀...</p>\n![avatar](/avatar_small.jpg)\n"},{"title":"标签","date":"2016-04-22T07:31:08.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2016-04-22 15:31:08\ntype: tags\ncomments: false\n---\n","updated":"2016-04-22T07:32:25.000Z","path":"tags/index.html","layout":"page","_id":"cip56hbax0019gr8f8vg0yhsk","content":"","excerpt":"","more":""}],"Post":[{"title":"在 OC 项目中使用基于 Swift 的 CocoaPods 库","date":"2016-05-12T08:57:28.000Z","_content":"\n随着 Swift 的流行，各种神奇的库也开始有对应的 Swift 版本了，而其中一些更神奇的库却只有 Swift 版本...\n正巧接手了一个前人用 Swift 写的项目，里面有一个非常关键的图表库，找了半天硬是没有发现类似的 OC 版开源库。出于不想造轮子的心态，就让我们这些\"落后\"的 OC 党想办法兼容这些库吧！好在苹果为了推广这门新语言已经做好了准备工作，虽然还是需要绕个路，但是比起造轮子来，还是简单了不少。\n\n<!-- more -->\n\n因为项目是用 CocoaPods 来管理第三方库的，所以这次的兼容工作也会在 CocoaPods 上展开。不过道理还是那个道理，如果没有用到 CocoaPods 的话，直接跳过下面关于 Podfile 的那一步就好了。\n\n## Podfile\n要用 CocoaPods，首先要修改的当然是 Podfile，这是最简单的一步，只需要在文件开始加上这一句：\n\n```\nuse_frameworks!\n```\n\n这是告诉 CocoaPods：“请把我要用到的第三方库用动态框架的形式集成进来”。\n因为 Apple 不允许开发者构建内含 Swift 代码的静态库，所以要往 OC 项目中集成第三方 Swift 代码的时候就只能通过动态框架（ framework ）的形式了。\n\n而 CocoaPods 还不能很好地将 framework 和静态库混编到一起，所以要么不用 framework，要用就要全部用上。关于这一点，[CocoaPods 官博](https://blog.cocoapods.org/CocoaPods-0.36/)上的原话是这样说的：\n> This is an all or nothing approach per integrated targets, because we can't ensure to properly build frameworks, whose transitive dependencies are static libraries.\n\n## Xcode配置\n这一步的操作比较绕，但总体来说还是简单的。\n\n首先在你的项目中任意创建一个 Swift 文件，这时候聪明的 Xcode 会问你需不需要它帮助你创建一个 Bridging 文件。\n![bridging-header](/uploads/Use-Swift-framework-in-OC-project/bridging-header.png)￼\n\n嘛，这当然是最好不过了，然而如果（像我这样）手贱点了 *Don't create* ，那以后不管你创建再多的 Swift 文件，它都不会问你了。不过，这当然是有手动操作的途径：\n\n1. 手动创建一个头文件，名字叫 `Your_Product_Module_Name-Bridging-Header.h`，注意不是 `Project_Name`。\n2. 确保你的项目目录下至少有一个 Swift 文件。\n3. 确保在 **Targets** 的 Build Settings 里，**Product Module Name** 是有值的。（如果没有，直接设置为 `$(PRODUCT_NAME)` 就可以了）\n4. 将 **Project** 的 Build Settings 里的 **Defines Modules** 设置为 `Yes`。（如果项目里没有创建过 Swift 文件的话，这个设置可能是不可见的）\n\n配置完成！进入代码环节！\n\n## 代码\n其实也不需要什么代码啦。\n\n完成了上面的所有步骤之后，Xcode 会自动生成一个名为 Your_Product_Module_Name-Swift.h 的文件，以后只要在需要使用到 Swift 代码的地方 import 这个文件就可以了。\n现在已经可以直接按照 OC 的语法去调用 Swift 里的属性和方法了，开始愉快地 coding 吧 :)\n\n> P.S. 为了避免循环引用，`-Swift.h` 文件只能在 `.m` 文件中 import。如果需要在 `.h` 文件中使用，就只能用 @class 来前向声明。\n\n\n## 参考文章\n* [苹果官方文档：Mix and Match](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122)\n* [Importing Project-Swift.h into a Objective-C class…file not found](http://stackoverflow.com/a/30202319)\n* [CocoaPods 0.36 - Framework and Swift Support](https://blog.cocoapods.org/CocoaPods-0.36/)\n","source":"_posts/Use-Swift-framework-in-OC-project.md","raw":"---\ntitle: 在 OC 项目中使用基于 Swift 的 CocoaPods 库\ndate: 2016-05-12 16:57:28\ntags:\n- iOS\n- Swift\n- CocoaPods\n---\n\n随着 Swift 的流行，各种神奇的库也开始有对应的 Swift 版本了，而其中一些更神奇的库却只有 Swift 版本...\n正巧接手了一个前人用 Swift 写的项目，里面有一个非常关键的图表库，找了半天硬是没有发现类似的 OC 版开源库。出于不想造轮子的心态，就让我们这些\"落后\"的 OC 党想办法兼容这些库吧！好在苹果为了推广这门新语言已经做好了准备工作，虽然还是需要绕个路，但是比起造轮子来，还是简单了不少。\n\n<!-- more -->\n\n因为项目是用 CocoaPods 来管理第三方库的，所以这次的兼容工作也会在 CocoaPods 上展开。不过道理还是那个道理，如果没有用到 CocoaPods 的话，直接跳过下面关于 Podfile 的那一步就好了。\n\n## Podfile\n要用 CocoaPods，首先要修改的当然是 Podfile，这是最简单的一步，只需要在文件开始加上这一句：\n\n```\nuse_frameworks!\n```\n\n这是告诉 CocoaPods：“请把我要用到的第三方库用动态框架的形式集成进来”。\n因为 Apple 不允许开发者构建内含 Swift 代码的静态库，所以要往 OC 项目中集成第三方 Swift 代码的时候就只能通过动态框架（ framework ）的形式了。\n\n而 CocoaPods 还不能很好地将 framework 和静态库混编到一起，所以要么不用 framework，要用就要全部用上。关于这一点，[CocoaPods 官博](https://blog.cocoapods.org/CocoaPods-0.36/)上的原话是这样说的：\n> This is an all or nothing approach per integrated targets, because we can't ensure to properly build frameworks, whose transitive dependencies are static libraries.\n\n## Xcode配置\n这一步的操作比较绕，但总体来说还是简单的。\n\n首先在你的项目中任意创建一个 Swift 文件，这时候聪明的 Xcode 会问你需不需要它帮助你创建一个 Bridging 文件。\n![bridging-header](/uploads/Use-Swift-framework-in-OC-project/bridging-header.png)￼\n\n嘛，这当然是最好不过了，然而如果（像我这样）手贱点了 *Don't create* ，那以后不管你创建再多的 Swift 文件，它都不会问你了。不过，这当然是有手动操作的途径：\n\n1. 手动创建一个头文件，名字叫 `Your_Product_Module_Name-Bridging-Header.h`，注意不是 `Project_Name`。\n2. 确保你的项目目录下至少有一个 Swift 文件。\n3. 确保在 **Targets** 的 Build Settings 里，**Product Module Name** 是有值的。（如果没有，直接设置为 `$(PRODUCT_NAME)` 就可以了）\n4. 将 **Project** 的 Build Settings 里的 **Defines Modules** 设置为 `Yes`。（如果项目里没有创建过 Swift 文件的话，这个设置可能是不可见的）\n\n配置完成！进入代码环节！\n\n## 代码\n其实也不需要什么代码啦。\n\n完成了上面的所有步骤之后，Xcode 会自动生成一个名为 Your_Product_Module_Name-Swift.h 的文件，以后只要在需要使用到 Swift 代码的地方 import 这个文件就可以了。\n现在已经可以直接按照 OC 的语法去调用 Swift 里的属性和方法了，开始愉快地 coding 吧 :)\n\n> P.S. 为了避免循环引用，`-Swift.h` 文件只能在 `.m` 文件中 import。如果需要在 `.h` 文件中使用，就只能用 @class 来前向声明。\n\n\n## 参考文章\n* [苹果官方文档：Mix and Match](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122)\n* [Importing Project-Swift.h into a Objective-C class…file not found](http://stackoverflow.com/a/30202319)\n* [CocoaPods 0.36 - Framework and Swift Support](https://blog.cocoapods.org/CocoaPods-0.36/)\n","slug":"Use-Swift-framework-in-OC-project","published":1,"updated":"2016-05-12T09:47:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip56hb6b0000gr8f82dkjt66","content":"<p>随着 Swift 的流行，各种神奇的库也开始有对应的 Swift 版本了，而其中一些更神奇的库却只有 Swift 版本...\n正巧接手了一个前人用 Swift 写的项目，里面有一个非常关键的图表库，找了半天硬是没有发现类似的 OC 版开源库。出于不想造轮子的心态，就让我们这些&quot;落后&quot;的 OC 党想办法兼容这些库吧！好在苹果为了推广这门新语言已经做好了准备工作，虽然还是需要绕个路，但是比起造轮子来，还是简单了不少。</p>\n<a id=\"more\"></a>\n<p>因为项目是用 CocoaPods 来管理第三方库的，所以这次的兼容工作也会在 CocoaPods 上展开。不过道理还是那个道理，如果没有用到 CocoaPods 的话，直接跳过下面关于 Podfile 的那一步就好了。</p>\n<h2>Podfile</h2>\n<p>要用 CocoaPods，首先要修改的当然是 Podfile，这是最简单的一步，只需要在文件开始加上这一句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use_frameworks!</span><br></pre></td></tr></table></figure>\n<p>这是告诉 CocoaPods：“请把我要用到的第三方库用动态框架的形式集成进来”。\n因为 Apple 不允许开发者构建内含 Swift 代码的静态库，所以要往 OC 项目中集成第三方 Swift 代码的时候就只能通过动态框架（ framework ）的形式了。</p>\n<p>而 CocoaPods 还不能很好地将 framework 和静态库混编到一起，所以要么不用 framework，要用就要全部用上。关于这一点，<a href=\"https://blog.cocoapods.org/CocoaPods-0.36/\" target=\"_blank\" rel=\"external\">CocoaPods 官博</a>上的原话是这样说的：</p>\n<blockquote>\n<p>This is an all or nothing approach per integrated targets, because we can't ensure to properly build frameworks, whose transitive dependencies are static libraries.</p>\n</blockquote>\n<h2>Xcode配置</h2>\n<p>这一步的操作比较绕，但总体来说还是简单的。</p>\n<p>首先在你的项目中任意创建一个 Swift 文件，这时候聪明的 Xcode 会问你需不需要它帮助你创建一个 Bridging 文件。\n<img src=\"/uploads/Use-Swift-framework-in-OC-project/bridging-header.png\" alt=\"bridging-header\">￼</p>\n<p>嘛，这当然是最好不过了，然而如果（像我这样）手贱点了 <em>Don't create</em> ，那以后不管你创建再多的 Swift 文件，它都不会问你了。不过，这当然是有手动操作的途径：</p>\n<ol>\n<li>手动创建一个头文件，名字叫 <code>Your_Product_Module_Name-Bridging-Header.h</code>，注意不是 <code>Project_Name</code>。</li>\n<li>确保你的项目目录下至少有一个 Swift 文件。</li>\n<li>确保在 <strong>Targets</strong> 的 Build Settings 里，<strong>Product Module Name</strong> 是有值的。（如果没有，直接设置为 <code>$(PRODUCT_NAME)</code> 就可以了）</li>\n<li>将 <strong>Project</strong> 的 Build Settings 里的 <strong>Defines Modules</strong> 设置为 <code>Yes</code>。（如果项目里没有创建过 Swift 文件的话，这个设置可能是不可见的）</li>\n</ol>\n<p>配置完成！进入代码环节！</p>\n<h2>代码</h2>\n<p>其实也不需要什么代码啦。</p>\n<p>完成了上面的所有步骤之后，Xcode 会自动生成一个名为 Your_Product_Module_Name-Swift.h 的文件，以后只要在需要使用到 Swift 代码的地方 import 这个文件就可以了。\n现在已经可以直接按照 OC 的语法去调用 Swift 里的属性和方法了，开始愉快地 coding 吧 :)</p>\n<blockquote>\n<p>P.S. 为了避免循环引用，<code>-Swift.h</code> 文件只能在 <code>.m</code> 文件中 import。如果需要在 <code>.h</code> 文件中使用，就只能用 @class 来前向声明。</p>\n</blockquote>\n<h2>参考文章</h2>\n<ul>\n<li><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122\" target=\"_blank\" rel=\"external\">苹果官方文档：Mix and Match</a></li>\n<li><a href=\"http://stackoverflow.com/a/30202319\" target=\"_blank\" rel=\"external\">Importing Project-Swift.h into a Objective-C class…file not found</a></li>\n<li><a href=\"https://blog.cocoapods.org/CocoaPods-0.36/\" target=\"_blank\" rel=\"external\">CocoaPods 0.36 - Framework and Swift Support</a></li>\n</ul>\n","excerpt":"<p>随着 Swift 的流行，各种神奇的库也开始有对应的 Swift 版本了，而其中一些更神奇的库却只有 Swift 版本...\n正巧接手了一个前人用 Swift 写的项目，里面有一个非常关键的图表库，找了半天硬是没有发现类似的 OC 版开源库。出于不想造轮子的心态，就让我们这些&quot;落后&quot;的 OC 党想办法兼容这些库吧！好在苹果为了推广这门新语言已经做好了准备工作，虽然还是需要绕个路，但是比起造轮子来，还是简单了不少。</p>","more":"<p>因为项目是用 CocoaPods 来管理第三方库的，所以这次的兼容工作也会在 CocoaPods 上展开。不过道理还是那个道理，如果没有用到 CocoaPods 的话，直接跳过下面关于 Podfile 的那一步就好了。</p>\n<h2>Podfile</h2>\n<p>要用 CocoaPods，首先要修改的当然是 Podfile，这是最简单的一步，只需要在文件开始加上这一句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use_frameworks!</span><br></pre></td></tr></table></figure>\n<p>这是告诉 CocoaPods：“请把我要用到的第三方库用动态框架的形式集成进来”。\n因为 Apple 不允许开发者构建内含 Swift 代码的静态库，所以要往 OC 项目中集成第三方 Swift 代码的时候就只能通过动态框架（ framework ）的形式了。</p>\n<p>而 CocoaPods 还不能很好地将 framework 和静态库混编到一起，所以要么不用 framework，要用就要全部用上。关于这一点，<a href=\"https://blog.cocoapods.org/CocoaPods-0.36/\">CocoaPods 官博</a>上的原话是这样说的：</p>\n<blockquote>\n<p>This is an all or nothing approach per integrated targets, because we can't ensure to properly build frameworks, whose transitive dependencies are static libraries.</p>\n</blockquote>\n<h2>Xcode配置</h2>\n<p>这一步的操作比较绕，但总体来说还是简单的。</p>\n<p>首先在你的项目中任意创建一个 Swift 文件，这时候聪明的 Xcode 会问你需不需要它帮助你创建一个 Bridging 文件。\n<img src=\"/uploads/Use-Swift-framework-in-OC-project/bridging-header.png\" alt=\"bridging-header\">￼</p>\n<p>嘛，这当然是最好不过了，然而如果（像我这样）手贱点了 <em>Don't create</em> ，那以后不管你创建再多的 Swift 文件，它都不会问你了。不过，这当然是有手动操作的途径：</p>\n<ol>\n<li>手动创建一个头文件，名字叫 <code>Your_Product_Module_Name-Bridging-Header.h</code>，注意不是 <code>Project_Name</code>。</li>\n<li>确保你的项目目录下至少有一个 Swift 文件。</li>\n<li>确保在 <strong>Targets</strong> 的 Build Settings 里，<strong>Product Module Name</strong> 是有值的。（如果没有，直接设置为 <code>$(PRODUCT_NAME)</code> 就可以了）</li>\n<li>将 <strong>Project</strong> 的 Build Settings 里的 <strong>Defines Modules</strong> 设置为 <code>Yes</code>。（如果项目里没有创建过 Swift 文件的话，这个设置可能是不可见的）</li>\n</ol>\n<p>配置完成！进入代码环节！</p>\n<h2>代码</h2>\n<p>其实也不需要什么代码啦。</p>\n<p>完成了上面的所有步骤之后，Xcode 会自动生成一个名为 Your_Product_Module_Name-Swift.h 的文件，以后只要在需要使用到 Swift 代码的地方 import 这个文件就可以了。\n现在已经可以直接按照 OC 的语法去调用 Swift 里的属性和方法了，开始愉快地 coding 吧 :)</p>\n<blockquote>\n<p>P.S. 为了避免循环引用，<code>-Swift.h</code> 文件只能在 <code>.m</code> 文件中 import。如果需要在 <code>.h</code> 文件中使用，就只能用 @class 来前向声明。</p>\n</blockquote>\n<h2>参考文章</h2>\n<ul>\n<li><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122\">苹果官方文档：Mix and Match</a></li>\n<li><a href=\"http://stackoverflow.com/a/30202319\">Importing Project-Swift.h into a Objective-C class…file not found</a></li>\n<li><a href=\"https://blog.cocoapods.org/CocoaPods-0.36/\">CocoaPods 0.36 - Framework and Swift Support</a></li>\n</ul>"},{"title":"AES是个什么鬼？","date":"2016-04-26T02:38:18.000Z","_content":"\n前段时间参加了部门的几次分享会，主题围绕着数字签名、数字证书和https相关的知识。这些方面的内容都不可避免的要涉及到数据加解密，于是趁热打铁，准备进行一次加解密相关基础的学习和分享。~~顺便扩充一下博客数量。~~\n这一篇是针对AES的学习笔记，主要的知识来源是维基百科和各种网络资源。\n因为时间有限，所以研究的不是非常深入，如果有不准确和错误的地方，希望能指出来一起讨论学习。\n\n<!-- more -->\n\n## 前世今生\nAES 的出现就是为了取代原来的数据加密标准（DES），作为爷爷级的加密算法，DES在风光过后也是到了该退休的年纪了。\n\n### 关于DES\n在继续了解AES之前，不妨先看看被它取代的DES是什么。\n它的全称为 **Data Encryption Standard** ，是一种对称密钥加密块算法，大致的加密流程长这个样子：\n![des-encrypt](/uploads/AES是个什么鬼？/des-encrypt.png)￼\n在进入到加密流程之前，64位的块被拆分为两个32位的子块，并作为 IP 的两个输入。中间的 F 是 Feistel function，算法中的密钥就是在这个函数中被用到的。\n\n> 块加密：Block cipher， 也叫作分组加密，是将明文分成多个等长模块（block），使用确定的算法和对称密钥对每组分别加密解密的方式。\n\nDES 在1976年曾经风光一时，被美国联邦政府的国家标准局定为 **联邦资料处理标准（FIPS）**。然而因为它只是用了56位的密钥，所以在当下已经不是一种安全的加密方法。在1999年1月，已经有组织在22小时15分钟内公开破解了一个DES密钥。\n\n> 后来出现了一种改进的 DES，叫 TDES 或 3DES。它本质上就是把密钥个数增加到了3个，并没有算法上的改进。（感觉很儿戏的样子）\n\n在2001年，DES已经不再是 **国际标准科技协会**（NIST，前 FIPS）的一个标准，而且也开始慢慢被AES所取代。\n\n### 言归正传\n\nAES，全称为 **Advanced Encryption Standard**，原名叫做 **Rijndael 加密法**。（还是新名字好念）\n> 至于一开始为什么有个这么拗口的名字，因为两位作者的名字是 Joan Daemen 和 Vincent Rijmen，发现为什么了吗？这是不是密码学家约定俗成的某种命名方式呢？\n\n2001年11月26日，美国的 NIST 公布了 AES 这一标准，并开始了长达5年的标准化进程，直到 Rijndael 被选为最适合的方法。\n在2002年5月26日，AES 成为了一项联邦政府标准。它还是联邦安全局（NSA）批准的唯一一种用来加密顶级机密信息的公开加密方法。\n\n> 也就是说，如果你想要黑 FBI，也许可以试试看 AES 解密 :)\n\n严格来说，AES 和 Rijndael 并不完全一样。AES 使用的是固定128位大小的块，密钥的大小只能是128位、192位或256位；而 Rijndael 使用的块大小和密钥长度可以是在128位和256位之间能被32整除的任意值，相对来说灵活性高了很多。\n\n## 主要过程\nAES加密算法的组成可以分成4个主要部分：\n1. AddRoundKey\n2. SubBytes\n3. ShiftRows\n4. MixColumns\n\n简单来说，就是将上面的几个部分组合起来形成三种不同的序列，然后把这些过程序列重复执行若干个回合，具体的循环次数由密钥的长度决定：\n* 128位密钥：循环10次\n* 192位密钥：循环12次\n* 256位密钥：循环14次\n\n这三种序列是：\n\n* 首次循环：\n\t1. AddRoundKey\n\n\n* 一般循环：\n\t1. SubBytes\n\t2. ShiftRows\n\t3. MixColumns\n\t4. AddRoundKey\n\n\n* 末尾循环：\n\t1. SubBytes\n\t2. ShiftRows\n\t3. AddRoundKey\n\n\n那么这几个部分到底是干了些什么呢？\n\n### AddRoundKey\n在每一次循环中，通过 [Rijndael 密钥生成方案](https://en.wikipedia.org/wiki/Rijndael_key_schedule)从主密钥中生成一个子密钥，这个子密钥的大小应该等同于块的大小，并且以列优先的方式排列在一个矩阵里（每个块也是以这样的方式排列在矩阵里的）。\n接下来将这个子密钥的值与块上对应位置的值 XOR 起来，形成一个新的矩阵，到这里这一过程就算完成了。\n![220px-AES-AddRoundKey.svg](/uploads/AES是个什么鬼？/AES-AddRoundKey.png)￼\n\n### SubBytes\n这一步会使用到一个叫做 Rijndael S-box 的东西，它其实就是一个8位的代换表，每一个字节的数据都可以在表中查到对应的代换结果。只要这个 S-box 在构建的时候足够好，就可以大大降低这次加密的线性关系。下面是一个6位 S-box 的例子，输入的值是011011，输出的值是1001。\n![S-box-DES--input011011](/uploads/AES是个什么鬼？/S-box-DES-input011011.png)￼\n\n将块矩阵中的每一个元素通过 S-box 进行代换，组成一个代换后的矩阵，就是 SubBytes 这一步的工作。\n![320px-AES-SubBytes.svg](/uploads/AES是个什么鬼？/AES-SubBytes.png)￼\n\n### ShiftRows\n这一步容易理解，就是把块矩阵中的每一行都进行一个向左循环移位，最后的效果是要让输出矩阵的每一列上的元素都属于输入矩阵原本不同的列。\n这样做可以保证每一列上的元素都是非线性相关的。\n![320px-AES-ShiftRows.svg](/uploads/AES是个什么鬼？/AES-ShiftRows.png)￼\n\n### MixColumns\n这个部分会接受4个字节的输入，并输出4个字节，而且每一个字节输入的字节都会对输出造成影响，所以它跟上面的 ShiftRows 一起为加密算法提供了良好的扩散性.\n\n> 扩散性（Diffusion）：如果改变了任意1位的原文，密文中一半以上的位也应该会跟着改变；反过来，改变了任意1位密文，得到的原文也应该有一半以上的位被改变。—— Stallings, William (2014). Cryptography and Network Security (6th ed.)\n\n简单来说，这一步就是讲输入矩阵的每一列与一个固定的多项式在一定条件下相乘。最终得到的将会是一个与输入矩阵完全不一样的输出矩阵。\n![320px-AES-MixColumns.svg](/uploads/AES是个什么鬼？/AES-MixColumns.png)￼\n\n> 更多资料\n> * [伽罗华域(Galois Field，GF，有限域)乘法运算](http://blog.csdn.net/mengboy/article/details/1514445)\n> * [Confusion and diffusion](https://en.wikipedia.org/wiki/Confusion_and_diffusion)\n\n## 填充算法\n对于块加密算法来说，如果数据的长度不满一个块的大小，我们就需要主动填充一些数据，让这个块的大小可以满足要求，于是，一个合适的填充算法就显得尤为重要。\n经过导师的提醒并且在网上读了一些博客之后发现，[Java端与iOS端使用的AES填充算法是不一样的](http://my.oschina.net/nicsun/blog/95632)，在 Java 端上使用的是 PKCS5Padding ，而在iOS端上使用的是 PKCS7Padding 。所以就会导致在其中一端上加解密没有问题，但是把密文发到另一端上解密就会得到完全不同的结果。\nP.S. 这里说到的 *Java 端* 应该是指服务器端，Android 端上不知道有没有这个问题。\n\n> PKCS5 相当于是 PKCS7 的一个子集，因为 PKCS7 理论上支持1~255字节的块大小填充，而 PKCS5 只支持8字节的块大小填充。其实 PKCS5 更多是应用在 DES/3DES 上。\n\n具体的填充过程也非常好理解，直接举例子好了：比如说块大小为8字节的加密算法，现在有一串长度为9的数据：\n`FF FF FF FF FF FF FF FF FF`（9个FF）\n使用 PKCS7 算法去填充的话，结果就是这样的\n`FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07`（9个FF和7个07）\n填充的目的就是把块给补满，所以这里填充的长度为7；而采用 PKCS7 算法的话，填充的每一个字节都是填充长度的十六进制数，那就也是7。\n\n> 有趣的是，如果采用 PKCS5 去填充，因为它的目标块大小是8，所以这里会填充一个01。详情可以参考[Can AES use PKCS#5 padding](http://crypto.stackexchange.com/a/11274)里的最佳答案。\n\n## 写在最后\n从上面的流程可以看出，一个逻辑严密的加密算法其实就是由一个个结构精巧的小算法构成的。在我看来，不深入到每个算法的内部，而只是看看它们之间的联系，还是蛮有意思的。研究算法的事情还是交给专业的人去做吧~\n\n## 参考资料\n* [Advanced Encryption Standard](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n* [Rijndael 密钥生成方案](https://en.wikipedia.org/wiki/Rijndael_key_schedule)\n* [伽罗华域(Galois Field，GF，有限域)乘法运算](http://blog.csdn.net/mengboy/article/details/1514445)\n* [Confusion and diffusion](https://en.wikipedia.org/wiki/Confusion_and_diffusion)\n* [关于AES256算法java端加密，ios端解密出现无法解密问题的解决方案](http://my.oschina.net/nicsun/blog/95632)\n* [Can AES use PKCS#5 padding](http://crypto.stackexchange.com/questions/11272/can-aes-use-pkcs5-padding)\n","source":"_posts/about-aes-encryption.md","raw":"---\ntitle: AES是个什么鬼？\ndate: 2016-04-26 10:38:18\ntags:\n- 加解密\n- 安全\n- AES\n- DES\n---\n\n前段时间参加了部门的几次分享会，主题围绕着数字签名、数字证书和https相关的知识。这些方面的内容都不可避免的要涉及到数据加解密，于是趁热打铁，准备进行一次加解密相关基础的学习和分享。~~顺便扩充一下博客数量。~~\n这一篇是针对AES的学习笔记，主要的知识来源是维基百科和各种网络资源。\n因为时间有限，所以研究的不是非常深入，如果有不准确和错误的地方，希望能指出来一起讨论学习。\n\n<!-- more -->\n\n## 前世今生\nAES 的出现就是为了取代原来的数据加密标准（DES），作为爷爷级的加密算法，DES在风光过后也是到了该退休的年纪了。\n\n### 关于DES\n在继续了解AES之前，不妨先看看被它取代的DES是什么。\n它的全称为 **Data Encryption Standard** ，是一种对称密钥加密块算法，大致的加密流程长这个样子：\n![des-encrypt](/uploads/AES是个什么鬼？/des-encrypt.png)￼\n在进入到加密流程之前，64位的块被拆分为两个32位的子块，并作为 IP 的两个输入。中间的 F 是 Feistel function，算法中的密钥就是在这个函数中被用到的。\n\n> 块加密：Block cipher， 也叫作分组加密，是将明文分成多个等长模块（block），使用确定的算法和对称密钥对每组分别加密解密的方式。\n\nDES 在1976年曾经风光一时，被美国联邦政府的国家标准局定为 **联邦资料处理标准（FIPS）**。然而因为它只是用了56位的密钥，所以在当下已经不是一种安全的加密方法。在1999年1月，已经有组织在22小时15分钟内公开破解了一个DES密钥。\n\n> 后来出现了一种改进的 DES，叫 TDES 或 3DES。它本质上就是把密钥个数增加到了3个，并没有算法上的改进。（感觉很儿戏的样子）\n\n在2001年，DES已经不再是 **国际标准科技协会**（NIST，前 FIPS）的一个标准，而且也开始慢慢被AES所取代。\n\n### 言归正传\n\nAES，全称为 **Advanced Encryption Standard**，原名叫做 **Rijndael 加密法**。（还是新名字好念）\n> 至于一开始为什么有个这么拗口的名字，因为两位作者的名字是 Joan Daemen 和 Vincent Rijmen，发现为什么了吗？这是不是密码学家约定俗成的某种命名方式呢？\n\n2001年11月26日，美国的 NIST 公布了 AES 这一标准，并开始了长达5年的标准化进程，直到 Rijndael 被选为最适合的方法。\n在2002年5月26日，AES 成为了一项联邦政府标准。它还是联邦安全局（NSA）批准的唯一一种用来加密顶级机密信息的公开加密方法。\n\n> 也就是说，如果你想要黑 FBI，也许可以试试看 AES 解密 :)\n\n严格来说，AES 和 Rijndael 并不完全一样。AES 使用的是固定128位大小的块，密钥的大小只能是128位、192位或256位；而 Rijndael 使用的块大小和密钥长度可以是在128位和256位之间能被32整除的任意值，相对来说灵活性高了很多。\n\n## 主要过程\nAES加密算法的组成可以分成4个主要部分：\n1. AddRoundKey\n2. SubBytes\n3. ShiftRows\n4. MixColumns\n\n简单来说，就是将上面的几个部分组合起来形成三种不同的序列，然后把这些过程序列重复执行若干个回合，具体的循环次数由密钥的长度决定：\n* 128位密钥：循环10次\n* 192位密钥：循环12次\n* 256位密钥：循环14次\n\n这三种序列是：\n\n* 首次循环：\n\t1. AddRoundKey\n\n\n* 一般循环：\n\t1. SubBytes\n\t2. ShiftRows\n\t3. MixColumns\n\t4. AddRoundKey\n\n\n* 末尾循环：\n\t1. SubBytes\n\t2. ShiftRows\n\t3. AddRoundKey\n\n\n那么这几个部分到底是干了些什么呢？\n\n### AddRoundKey\n在每一次循环中，通过 [Rijndael 密钥生成方案](https://en.wikipedia.org/wiki/Rijndael_key_schedule)从主密钥中生成一个子密钥，这个子密钥的大小应该等同于块的大小，并且以列优先的方式排列在一个矩阵里（每个块也是以这样的方式排列在矩阵里的）。\n接下来将这个子密钥的值与块上对应位置的值 XOR 起来，形成一个新的矩阵，到这里这一过程就算完成了。\n![220px-AES-AddRoundKey.svg](/uploads/AES是个什么鬼？/AES-AddRoundKey.png)￼\n\n### SubBytes\n这一步会使用到一个叫做 Rijndael S-box 的东西，它其实就是一个8位的代换表，每一个字节的数据都可以在表中查到对应的代换结果。只要这个 S-box 在构建的时候足够好，就可以大大降低这次加密的线性关系。下面是一个6位 S-box 的例子，输入的值是011011，输出的值是1001。\n![S-box-DES--input011011](/uploads/AES是个什么鬼？/S-box-DES-input011011.png)￼\n\n将块矩阵中的每一个元素通过 S-box 进行代换，组成一个代换后的矩阵，就是 SubBytes 这一步的工作。\n![320px-AES-SubBytes.svg](/uploads/AES是个什么鬼？/AES-SubBytes.png)￼\n\n### ShiftRows\n这一步容易理解，就是把块矩阵中的每一行都进行一个向左循环移位，最后的效果是要让输出矩阵的每一列上的元素都属于输入矩阵原本不同的列。\n这样做可以保证每一列上的元素都是非线性相关的。\n![320px-AES-ShiftRows.svg](/uploads/AES是个什么鬼？/AES-ShiftRows.png)￼\n\n### MixColumns\n这个部分会接受4个字节的输入，并输出4个字节，而且每一个字节输入的字节都会对输出造成影响，所以它跟上面的 ShiftRows 一起为加密算法提供了良好的扩散性.\n\n> 扩散性（Diffusion）：如果改变了任意1位的原文，密文中一半以上的位也应该会跟着改变；反过来，改变了任意1位密文，得到的原文也应该有一半以上的位被改变。—— Stallings, William (2014). Cryptography and Network Security (6th ed.)\n\n简单来说，这一步就是讲输入矩阵的每一列与一个固定的多项式在一定条件下相乘。最终得到的将会是一个与输入矩阵完全不一样的输出矩阵。\n![320px-AES-MixColumns.svg](/uploads/AES是个什么鬼？/AES-MixColumns.png)￼\n\n> 更多资料\n> * [伽罗华域(Galois Field，GF，有限域)乘法运算](http://blog.csdn.net/mengboy/article/details/1514445)\n> * [Confusion and diffusion](https://en.wikipedia.org/wiki/Confusion_and_diffusion)\n\n## 填充算法\n对于块加密算法来说，如果数据的长度不满一个块的大小，我们就需要主动填充一些数据，让这个块的大小可以满足要求，于是，一个合适的填充算法就显得尤为重要。\n经过导师的提醒并且在网上读了一些博客之后发现，[Java端与iOS端使用的AES填充算法是不一样的](http://my.oschina.net/nicsun/blog/95632)，在 Java 端上使用的是 PKCS5Padding ，而在iOS端上使用的是 PKCS7Padding 。所以就会导致在其中一端上加解密没有问题，但是把密文发到另一端上解密就会得到完全不同的结果。\nP.S. 这里说到的 *Java 端* 应该是指服务器端，Android 端上不知道有没有这个问题。\n\n> PKCS5 相当于是 PKCS7 的一个子集，因为 PKCS7 理论上支持1~255字节的块大小填充，而 PKCS5 只支持8字节的块大小填充。其实 PKCS5 更多是应用在 DES/3DES 上。\n\n具体的填充过程也非常好理解，直接举例子好了：比如说块大小为8字节的加密算法，现在有一串长度为9的数据：\n`FF FF FF FF FF FF FF FF FF`（9个FF）\n使用 PKCS7 算法去填充的话，结果就是这样的\n`FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07`（9个FF和7个07）\n填充的目的就是把块给补满，所以这里填充的长度为7；而采用 PKCS7 算法的话，填充的每一个字节都是填充长度的十六进制数，那就也是7。\n\n> 有趣的是，如果采用 PKCS5 去填充，因为它的目标块大小是8，所以这里会填充一个01。详情可以参考[Can AES use PKCS#5 padding](http://crypto.stackexchange.com/a/11274)里的最佳答案。\n\n## 写在最后\n从上面的流程可以看出，一个逻辑严密的加密算法其实就是由一个个结构精巧的小算法构成的。在我看来，不深入到每个算法的内部，而只是看看它们之间的联系，还是蛮有意思的。研究算法的事情还是交给专业的人去做吧~\n\n## 参考资料\n* [Advanced Encryption Standard](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n* [Rijndael 密钥生成方案](https://en.wikipedia.org/wiki/Rijndael_key_schedule)\n* [伽罗华域(Galois Field，GF，有限域)乘法运算](http://blog.csdn.net/mengboy/article/details/1514445)\n* [Confusion and diffusion](https://en.wikipedia.org/wiki/Confusion_and_diffusion)\n* [关于AES256算法java端加密，ios端解密出现无法解密问题的解决方案](http://my.oschina.net/nicsun/blog/95632)\n* [Can AES use PKCS#5 padding](http://crypto.stackexchange.com/questions/11272/can-aes-use-pkcs5-padding)\n","slug":"about-aes-encryption","published":1,"updated":"2016-05-04T09:39:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip56hb6h0002gr8f9363o3q3","content":"<p>前段时间参加了部门的几次分享会，主题围绕着数字签名、数字证书和https相关的知识。这些方面的内容都不可避免的要涉及到数据加解密，于是趁热打铁，准备进行一次加解密相关基础的学习和分享。<s>顺便扩充一下博客数量。</s>\n这一篇是针对AES的学习笔记，主要的知识来源是维基百科和各种网络资源。\n因为时间有限，所以研究的不是非常深入，如果有不准确和错误的地方，希望能指出来一起讨论学习。</p>\n<a id=\"more\"></a>\n<h2>前世今生</h2>\n<p>AES 的出现就是为了取代原来的数据加密标准（DES），作为爷爷级的加密算法，DES在风光过后也是到了该退休的年纪了。</p>\n<h3>关于DES</h3>\n<p>在继续了解AES之前，不妨先看看被它取代的DES是什么。\n它的全称为 <strong>Data Encryption Standard</strong> ，是一种对称密钥加密块算法，大致的加密流程长这个样子：\n<img src=\"/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/des-encrypt.png\" alt=\"des-encrypt\">￼\n在进入到加密流程之前，64位的块被拆分为两个32位的子块，并作为 IP 的两个输入。中间的 F 是 Feistel function，算法中的密钥就是在这个函数中被用到的。</p>\n<blockquote>\n<p>块加密：Block cipher， 也叫作分组加密，是将明文分成多个等长模块（block），使用确定的算法和对称密钥对每组分别加密解密的方式。</p>\n</blockquote>\n<p>DES 在1976年曾经风光一时，被美国联邦政府的国家标准局定为 <strong>联邦资料处理标准（FIPS）</strong>。然而因为它只是用了56位的密钥，所以在当下已经不是一种安全的加密方法。在1999年1月，已经有组织在22小时15分钟内公开破解了一个DES密钥。</p>\n<blockquote>\n<p>后来出现了一种改进的 DES，叫 TDES 或 3DES。它本质上就是把密钥个数增加到了3个，并没有算法上的改进。（感觉很儿戏的样子）</p>\n</blockquote>\n<p>在2001年，DES已经不再是 <strong>国际标准科技协会</strong>（NIST，前 FIPS）的一个标准，而且也开始慢慢被AES所取代。</p>\n<h3>言归正传</h3>\n<p>AES，全称为 <strong>Advanced Encryption Standard</strong>，原名叫做 <strong>Rijndael 加密法</strong>。（还是新名字好念）</p>\n<blockquote>\n<p>至于一开始为什么有个这么拗口的名字，因为两位作者的名字是 Joan Daemen 和 Vincent Rijmen，发现为什么了吗？这是不是密码学家约定俗成的某种命名方式呢？</p>\n</blockquote>\n<p>2001年11月26日，美国的 NIST 公布了 AES 这一标准，并开始了长达5年的标准化进程，直到 Rijndael 被选为最适合的方法。\n在2002年5月26日，AES 成为了一项联邦政府标准。它还是联邦安全局（NSA）批准的唯一一种用来加密顶级机密信息的公开加密方法。</p>\n<blockquote>\n<p>也就是说，如果你想要黑 FBI，也许可以试试看 AES 解密 :)</p>\n</blockquote>\n<p>严格来说，AES 和 Rijndael 并不完全一样。AES 使用的是固定128位大小的块，密钥的大小只能是128位、192位或256位；而 Rijndael 使用的块大小和密钥长度可以是在128位和256位之间能被32整除的任意值，相对来说灵活性高了很多。</p>\n<h2>主要过程</h2>\n<p>AES加密算法的组成可以分成4个主要部分：</p>\n<ol>\n<li>AddRoundKey</li>\n<li>SubBytes</li>\n<li>ShiftRows</li>\n<li>MixColumns</li>\n</ol>\n<p>简单来说，就是将上面的几个部分组合起来形成三种不同的序列，然后把这些过程序列重复执行若干个回合，具体的循环次数由密钥的长度决定：</p>\n<ul>\n<li>128位密钥：循环10次</li>\n<li>192位密钥：循环12次</li>\n<li>256位密钥：循环14次</li>\n</ul>\n<p>这三种序列是：</p>\n<ul>\n<li>首次循环：\n<ol>\n<li>AddRoundKey</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>一般循环：\n<ol>\n<li>SubBytes</li>\n<li>ShiftRows</li>\n<li>MixColumns</li>\n<li>AddRoundKey</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>末尾循环：\n<ol>\n<li>SubBytes</li>\n<li>ShiftRows</li>\n<li>AddRoundKey</li>\n</ol>\n</li>\n</ul>\n<p>那么这几个部分到底是干了些什么呢？</p>\n<h3>AddRoundKey</h3>\n<p>在每一次循环中，通过 <a href=\"https://en.wikipedia.org/wiki/Rijndael_key_schedule\" target=\"_blank\" rel=\"external\">Rijndael 密钥生成方案</a>从主密钥中生成一个子密钥，这个子密钥的大小应该等同于块的大小，并且以列优先的方式排列在一个矩阵里（每个块也是以这样的方式排列在矩阵里的）。\n接下来将这个子密钥的值与块上对应位置的值 XOR 起来，形成一个新的矩阵，到这里这一过程就算完成了。\n<img src=\"/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/AES-AddRoundKey.png\" alt=\"220px-AES-AddRoundKey.svg\">￼</p>\n<h3>SubBytes</h3>\n<p>这一步会使用到一个叫做 Rijndael S-box 的东西，它其实就是一个8位的代换表，每一个字节的数据都可以在表中查到对应的代换结果。只要这个 S-box 在构建的时候足够好，就可以大大降低这次加密的线性关系。下面是一个6位 S-box 的例子，输入的值是011011，输出的值是1001。\n<img src=\"/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/S-box-DES-input011011.png\" alt=\"S-box-DES--input011011\">￼</p>\n<p>将块矩阵中的每一个元素通过 S-box 进行代换，组成一个代换后的矩阵，就是 SubBytes 这一步的工作。\n<img src=\"/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/AES-SubBytes.png\" alt=\"320px-AES-SubBytes.svg\">￼</p>\n<h3>ShiftRows</h3>\n<p>这一步容易理解，就是把块矩阵中的每一行都进行一个向左循环移位，最后的效果是要让输出矩阵的每一列上的元素都属于输入矩阵原本不同的列。\n这样做可以保证每一列上的元素都是非线性相关的。\n<img src=\"/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/AES-ShiftRows.png\" alt=\"320px-AES-ShiftRows.svg\">￼</p>\n<h3>MixColumns</h3>\n<p>这个部分会接受4个字节的输入，并输出4个字节，而且每一个字节输入的字节都会对输出造成影响，所以它跟上面的 ShiftRows 一起为加密算法提供了良好的扩散性.</p>\n<blockquote>\n<p>扩散性（Diffusion）：如果改变了任意1位的原文，密文中一半以上的位也应该会跟着改变；反过来，改变了任意1位密文，得到的原文也应该有一半以上的位被改变。—— Stallings, William (2014). Cryptography and Network Security (6th ed.)</p>\n</blockquote>\n<p>简单来说，这一步就是讲输入矩阵的每一列与一个固定的多项式在一定条件下相乘。最终得到的将会是一个与输入矩阵完全不一样的输出矩阵。\n<img src=\"/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/AES-MixColumns.png\" alt=\"320px-AES-MixColumns.svg\">￼</p>\n<blockquote>\n<p>更多资料</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/mengboy/article/details/1514445\" target=\"_blank\" rel=\"external\">伽罗华域(Galois Field，GF，有限域)乘法运算</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Confusion_and_diffusion\" target=\"_blank\" rel=\"external\">Confusion and diffusion</a></li>\n</ul>\n</blockquote>\n<h2>填充算法</h2>\n<p>对于块加密算法来说，如果数据的长度不满一个块的大小，我们就需要主动填充一些数据，让这个块的大小可以满足要求，于是，一个合适的填充算法就显得尤为重要。\n经过导师的提醒并且在网上读了一些博客之后发现，<a href=\"http://my.oschina.net/nicsun/blog/95632\" target=\"_blank\" rel=\"external\">Java端与iOS端使用的AES填充算法是不一样的</a>，在 Java 端上使用的是 PKCS5Padding ，而在iOS端上使用的是 PKCS7Padding 。所以就会导致在其中一端上加解密没有问题，但是把密文发到另一端上解密就会得到完全不同的结果。\nP.S. 这里说到的 <em>Java 端</em> 应该是指服务器端，Android 端上不知道有没有这个问题。</p>\n<blockquote>\n<p>PKCS5 相当于是 PKCS7 的一个子集，因为 PKCS7 理论上支持1~255字节的块大小填充，而 PKCS5 只支持8字节的块大小填充。其实 PKCS5 更多是应用在 DES/3DES 上。</p>\n</blockquote>\n<p>具体的填充过程也非常好理解，直接举例子好了：比如说块大小为8字节的加密算法，现在有一串长度为9的数据：\n<code>FF FF FF FF FF FF FF FF FF</code>（9个FF）\n使用 PKCS7 算法去填充的话，结果就是这样的\n<code>FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07</code>（9个FF和7个07）\n填充的目的就是把块给补满，所以这里填充的长度为7；而采用 PKCS7 算法的话，填充的每一个字节都是填充长度的十六进制数，那就也是7。</p>\n<blockquote>\n<p>有趣的是，如果采用 PKCS5 去填充，因为它的目标块大小是8，所以这里会填充一个01。详情可以参考<a href=\"http://crypto.stackexchange.com/a/11274\" target=\"_blank\" rel=\"external\">Can AES use PKCS#5 padding</a>里的最佳答案。</p>\n</blockquote>\n<h2>写在最后</h2>\n<p>从上面的流程可以看出，一个逻辑严密的加密算法其实就是由一个个结构精巧的小算法构成的。在我看来，不深入到每个算法的内部，而只是看看它们之间的联系，还是蛮有意思的。研究算法的事情还是交给专业的人去做吧~</p>\n<h2>参考资料</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Advanced_Encryption_Standard\" target=\"_blank\" rel=\"external\">Advanced Encryption Standard</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Rijndael_key_schedule\" target=\"_blank\" rel=\"external\">Rijndael 密钥生成方案</a></li>\n<li><a href=\"http://blog.csdn.net/mengboy/article/details/1514445\" target=\"_blank\" rel=\"external\">伽罗华域(Galois Field，GF，有限域)乘法运算</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Confusion_and_diffusion\" target=\"_blank\" rel=\"external\">Confusion and diffusion</a></li>\n<li><a href=\"http://my.oschina.net/nicsun/blog/95632\" target=\"_blank\" rel=\"external\">关于AES256算法java端加密，ios端解密出现无法解密问题的解决方案</a></li>\n<li><a href=\"http://crypto.stackexchange.com/questions/11272/can-aes-use-pkcs5-padding\" target=\"_blank\" rel=\"external\">Can AES use PKCS#5 padding</a></li>\n</ul>\n","excerpt":"<p>前段时间参加了部门的几次分享会，主题围绕着数字签名、数字证书和https相关的知识。这些方面的内容都不可避免的要涉及到数据加解密，于是趁热打铁，准备进行一次加解密相关基础的学习和分享。<s>顺便扩充一下博客数量。</s>\n这一篇是针对AES的学习笔记，主要的知识来源是维基百科和各种网络资源。\n因为时间有限，所以研究的不是非常深入，如果有不准确和错误的地方，希望能指出来一起讨论学习。</p>","more":"<h2>前世今生</h2>\n<p>AES 的出现就是为了取代原来的数据加密标准（DES），作为爷爷级的加密算法，DES在风光过后也是到了该退休的年纪了。</p>\n<h3>关于DES</h3>\n<p>在继续了解AES之前，不妨先看看被它取代的DES是什么。\n它的全称为 <strong>Data Encryption Standard</strong> ，是一种对称密钥加密块算法，大致的加密流程长这个样子：\n<img src=\"/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/des-encrypt.png\" alt=\"des-encrypt\">￼\n在进入到加密流程之前，64位的块被拆分为两个32位的子块，并作为 IP 的两个输入。中间的 F 是 Feistel function，算法中的密钥就是在这个函数中被用到的。</p>\n<blockquote>\n<p>块加密：Block cipher， 也叫作分组加密，是将明文分成多个等长模块（block），使用确定的算法和对称密钥对每组分别加密解密的方式。</p>\n</blockquote>\n<p>DES 在1976年曾经风光一时，被美国联邦政府的国家标准局定为 <strong>联邦资料处理标准（FIPS）</strong>。然而因为它只是用了56位的密钥，所以在当下已经不是一种安全的加密方法。在1999年1月，已经有组织在22小时15分钟内公开破解了一个DES密钥。</p>\n<blockquote>\n<p>后来出现了一种改进的 DES，叫 TDES 或 3DES。它本质上就是把密钥个数增加到了3个，并没有算法上的改进。（感觉很儿戏的样子）</p>\n</blockquote>\n<p>在2001年，DES已经不再是 <strong>国际标准科技协会</strong>（NIST，前 FIPS）的一个标准，而且也开始慢慢被AES所取代。</p>\n<h3>言归正传</h3>\n<p>AES，全称为 <strong>Advanced Encryption Standard</strong>，原名叫做 <strong>Rijndael 加密法</strong>。（还是新名字好念）</p>\n<blockquote>\n<p>至于一开始为什么有个这么拗口的名字，因为两位作者的名字是 Joan Daemen 和 Vincent Rijmen，发现为什么了吗？这是不是密码学家约定俗成的某种命名方式呢？</p>\n</blockquote>\n<p>2001年11月26日，美国的 NIST 公布了 AES 这一标准，并开始了长达5年的标准化进程，直到 Rijndael 被选为最适合的方法。\n在2002年5月26日，AES 成为了一项联邦政府标准。它还是联邦安全局（NSA）批准的唯一一种用来加密顶级机密信息的公开加密方法。</p>\n<blockquote>\n<p>也就是说，如果你想要黑 FBI，也许可以试试看 AES 解密 :)</p>\n</blockquote>\n<p>严格来说，AES 和 Rijndael 并不完全一样。AES 使用的是固定128位大小的块，密钥的大小只能是128位、192位或256位；而 Rijndael 使用的块大小和密钥长度可以是在128位和256位之间能被32整除的任意值，相对来说灵活性高了很多。</p>\n<h2>主要过程</h2>\n<p>AES加密算法的组成可以分成4个主要部分：</p>\n<ol>\n<li>AddRoundKey</li>\n<li>SubBytes</li>\n<li>ShiftRows</li>\n<li>MixColumns</li>\n</ol>\n<p>简单来说，就是将上面的几个部分组合起来形成三种不同的序列，然后把这些过程序列重复执行若干个回合，具体的循环次数由密钥的长度决定：</p>\n<ul>\n<li>128位密钥：循环10次</li>\n<li>192位密钥：循环12次</li>\n<li>256位密钥：循环14次</li>\n</ul>\n<p>这三种序列是：</p>\n<ul>\n<li>首次循环：\n<ol>\n<li>AddRoundKey</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>一般循环：\n<ol>\n<li>SubBytes</li>\n<li>ShiftRows</li>\n<li>MixColumns</li>\n<li>AddRoundKey</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>末尾循环：\n<ol>\n<li>SubBytes</li>\n<li>ShiftRows</li>\n<li>AddRoundKey</li>\n</ol>\n</li>\n</ul>\n<p>那么这几个部分到底是干了些什么呢？</p>\n<h3>AddRoundKey</h3>\n<p>在每一次循环中，通过 <a href=\"https://en.wikipedia.org/wiki/Rijndael_key_schedule\">Rijndael 密钥生成方案</a>从主密钥中生成一个子密钥，这个子密钥的大小应该等同于块的大小，并且以列优先的方式排列在一个矩阵里（每个块也是以这样的方式排列在矩阵里的）。\n接下来将这个子密钥的值与块上对应位置的值 XOR 起来，形成一个新的矩阵，到这里这一过程就算完成了。\n<img src=\"/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/AES-AddRoundKey.png\" alt=\"220px-AES-AddRoundKey.svg\">￼</p>\n<h3>SubBytes</h3>\n<p>这一步会使用到一个叫做 Rijndael S-box 的东西，它其实就是一个8位的代换表，每一个字节的数据都可以在表中查到对应的代换结果。只要这个 S-box 在构建的时候足够好，就可以大大降低这次加密的线性关系。下面是一个6位 S-box 的例子，输入的值是011011，输出的值是1001。\n<img src=\"/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/S-box-DES-input011011.png\" alt=\"S-box-DES--input011011\">￼</p>\n<p>将块矩阵中的每一个元素通过 S-box 进行代换，组成一个代换后的矩阵，就是 SubBytes 这一步的工作。\n<img src=\"/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/AES-SubBytes.png\" alt=\"320px-AES-SubBytes.svg\">￼</p>\n<h3>ShiftRows</h3>\n<p>这一步容易理解，就是把块矩阵中的每一行都进行一个向左循环移位，最后的效果是要让输出矩阵的每一列上的元素都属于输入矩阵原本不同的列。\n这样做可以保证每一列上的元素都是非线性相关的。\n<img src=\"/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/AES-ShiftRows.png\" alt=\"320px-AES-ShiftRows.svg\">￼</p>\n<h3>MixColumns</h3>\n<p>这个部分会接受4个字节的输入，并输出4个字节，而且每一个字节输入的字节都会对输出造成影响，所以它跟上面的 ShiftRows 一起为加密算法提供了良好的扩散性.</p>\n<blockquote>\n<p>扩散性（Diffusion）：如果改变了任意1位的原文，密文中一半以上的位也应该会跟着改变；反过来，改变了任意1位密文，得到的原文也应该有一半以上的位被改变。—— Stallings, William (2014). Cryptography and Network Security (6th ed.)</p>\n</blockquote>\n<p>简单来说，这一步就是讲输入矩阵的每一列与一个固定的多项式在一定条件下相乘。最终得到的将会是一个与输入矩阵完全不一样的输出矩阵。\n<img src=\"/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/AES-MixColumns.png\" alt=\"320px-AES-MixColumns.svg\">￼</p>\n<blockquote>\n<p>更多资料</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/mengboy/article/details/1514445\">伽罗华域(Galois Field，GF，有限域)乘法运算</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Confusion_and_diffusion\">Confusion and diffusion</a></li>\n</ul>\n</blockquote>\n<h2>填充算法</h2>\n<p>对于块加密算法来说，如果数据的长度不满一个块的大小，我们就需要主动填充一些数据，让这个块的大小可以满足要求，于是，一个合适的填充算法就显得尤为重要。\n经过导师的提醒并且在网上读了一些博客之后发现，<a href=\"http://my.oschina.net/nicsun/blog/95632\">Java端与iOS端使用的AES填充算法是不一样的</a>，在 Java 端上使用的是 PKCS5Padding ，而在iOS端上使用的是 PKCS7Padding 。所以就会导致在其中一端上加解密没有问题，但是把密文发到另一端上解密就会得到完全不同的结果。\nP.S. 这里说到的 <em>Java 端</em> 应该是指服务器端，Android 端上不知道有没有这个问题。</p>\n<blockquote>\n<p>PKCS5 相当于是 PKCS7 的一个子集，因为 PKCS7 理论上支持1~255字节的块大小填充，而 PKCS5 只支持8字节的块大小填充。其实 PKCS5 更多是应用在 DES/3DES 上。</p>\n</blockquote>\n<p>具体的填充过程也非常好理解，直接举例子好了：比如说块大小为8字节的加密算法，现在有一串长度为9的数据：\n<code>FF FF FF FF FF FF FF FF FF</code>（9个FF）\n使用 PKCS7 算法去填充的话，结果就是这样的\n<code>FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07</code>（9个FF和7个07）\n填充的目的就是把块给补满，所以这里填充的长度为7；而采用 PKCS7 算法的话，填充的每一个字节都是填充长度的十六进制数，那就也是7。</p>\n<blockquote>\n<p>有趣的是，如果采用 PKCS5 去填充，因为它的目标块大小是8，所以这里会填充一个01。详情可以参考<a href=\"http://crypto.stackexchange.com/a/11274\">Can AES use PKCS#5 padding</a>里的最佳答案。</p>\n</blockquote>\n<h2>写在最后</h2>\n<p>从上面的流程可以看出，一个逻辑严密的加密算法其实就是由一个个结构精巧的小算法构成的。在我看来，不深入到每个算法的内部，而只是看看它们之间的联系，还是蛮有意思的。研究算法的事情还是交给专业的人去做吧~</p>\n<h2>参考资料</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Advanced_Encryption_Standard\">Advanced Encryption Standard</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Rijndael_key_schedule\">Rijndael 密钥生成方案</a></li>\n<li><a href=\"http://blog.csdn.net/mengboy/article/details/1514445\">伽罗华域(Galois Field，GF，有限域)乘法运算</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Confusion_and_diffusion\">Confusion and diffusion</a></li>\n<li><a href=\"http://my.oschina.net/nicsun/blog/95632\">关于AES256算法java端加密，ios端解密出现无法解密问题的解决方案</a></li>\n<li><a href=\"http://crypto.stackexchange.com/questions/11272/can-aes-use-pkcs5-padding\">Can AES use PKCS#5 padding</a></li>\n</ul>"},{"title":"给哈希加点盐","date":"2016-04-26T02:45:32.000Z","_content":"\n又一篇学习笔记，这篇比较水，相当于是把原文给简化了一下，如果想要深入了解的话推荐还是看看原文[加盐hash保存密码的正确方式](http://drops.wooyun.org/papers/1066).\n\n基于 [Kerckhoffs's principle](https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle)，我们需要一种没有人能“看懂”但是又可以被验证的密码系统，听起来非常矛盾，但是哈希算法恰好满足了这个要求，于是通过加盐 hash 保存密码的方式应该是市面上比较稳妥的做法了。\n在说明加盐是什么之前，先来看看它所使用到的 Hash 的作用和一些常见的密码破解手段，相信看完之后，”为什么要加盐”这个问题也就自然而然的解决了。\n\n<!-- more -->\n\n## Hash\nHash 算法是一种单向的函数，它可以把任意数量的数据转换成固定长度的 *指纹*，这个过程是不可逆的，而且只要输入的数据中有一丝改变，结果的 hash 值也会有很大的不同。\n这里的 Hash 算法跟数据结构上的 hash 函数不完全相同，根据不同的使用场景，需要使用具有不同特性的 hash 函数。实现 hash 表的函数具有快速的特点，而加密 hash 函数是用来进行密码加密的，所以必须要确保安全性，比如 SHA256、SHA512、RipeMD、WHIRLPOOL。\n\n## 一些常见的破解手段\n### 字典&暴力破解\n基本上一切密码都可以用这种途径来破解，只是时间长短的问题了。\n\n* 字典破解：根据所有能找到的常用密码，生成一个密码字典，然后遍历字典中的值，一个个去尝试\n* 暴力破解：对于给定长度的密码，尝试每一种可能的字符组合。\n\n既然没有办法阻止这种破解方式，那么只能让这种方式变得低效，从而达到花费时间不可接受的地步，让破解者主动放弃。\n\n### 查表破解\n其实就是密码破解的进阶版。将密码字典中的每一个密码的 hash 值预先计算出来，放到另一张表里，这样做可以加快配对的速度。缺点是建立这个 hash 表需要耗费比较长的时间。\n\n### 反向查表破解\n这一招是针对同时破解大量用户的时候用的。\n一般的密码破解的本质是：对同一个用户名，用不同的密码去试，看看哪个是正确的。\n而反向查表的本质是：用一个密码去试所有用户，看看谁在用这个密码，一直换密码直到表里面所有的密码都试过了。\n\n这里用的表还是查表破解里经过了 hash 加密的密码表。\n\n### 彩虹表\n一种用时间换取了空间的表，牺牲了一些破解时间，以求表内包含的密码更全面。目前已经可以破解8位长度的任意 MD5 hash 。\n\n## 加盐\n各种查表的方法之所以有效，是因为 hash 函数的特性导致的，只要用户的密码相同，得到的 hash 值也一定相同。但是如果给每个人的密码加上一个随机的字符串再进行加密，那么即使两个用户使用了同一个密码，他们的密码存在数据库中的 hash 值也是不同的。\n这个随机的字符串就是盐（salt）。\n\n> 盐本身不需要保密，因为它的作用只是为了让各种表没那么容易生成。如果每次都要针对特定用户生成一个特定的表，那这个加盐的效果就达到了。\n\n## 参考资料\n* [加盐hash保存密码的正确方式](http://drops.wooyun.org/papers/1066)\n","source":"_posts/hash-with-salt.md","raw":"---\ntitle: 给哈希加点盐\ndate: 2016-04-26 10:45:32\ntags:\n- 加解密\n- 安全\n- Hash\n- Salt\n---\n\n又一篇学习笔记，这篇比较水，相当于是把原文给简化了一下，如果想要深入了解的话推荐还是看看原文[加盐hash保存密码的正确方式](http://drops.wooyun.org/papers/1066).\n\n基于 [Kerckhoffs's principle](https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle)，我们需要一种没有人能“看懂”但是又可以被验证的密码系统，听起来非常矛盾，但是哈希算法恰好满足了这个要求，于是通过加盐 hash 保存密码的方式应该是市面上比较稳妥的做法了。\n在说明加盐是什么之前，先来看看它所使用到的 Hash 的作用和一些常见的密码破解手段，相信看完之后，”为什么要加盐”这个问题也就自然而然的解决了。\n\n<!-- more -->\n\n## Hash\nHash 算法是一种单向的函数，它可以把任意数量的数据转换成固定长度的 *指纹*，这个过程是不可逆的，而且只要输入的数据中有一丝改变，结果的 hash 值也会有很大的不同。\n这里的 Hash 算法跟数据结构上的 hash 函数不完全相同，根据不同的使用场景，需要使用具有不同特性的 hash 函数。实现 hash 表的函数具有快速的特点，而加密 hash 函数是用来进行密码加密的，所以必须要确保安全性，比如 SHA256、SHA512、RipeMD、WHIRLPOOL。\n\n## 一些常见的破解手段\n### 字典&暴力破解\n基本上一切密码都可以用这种途径来破解，只是时间长短的问题了。\n\n* 字典破解：根据所有能找到的常用密码，生成一个密码字典，然后遍历字典中的值，一个个去尝试\n* 暴力破解：对于给定长度的密码，尝试每一种可能的字符组合。\n\n既然没有办法阻止这种破解方式，那么只能让这种方式变得低效，从而达到花费时间不可接受的地步，让破解者主动放弃。\n\n### 查表破解\n其实就是密码破解的进阶版。将密码字典中的每一个密码的 hash 值预先计算出来，放到另一张表里，这样做可以加快配对的速度。缺点是建立这个 hash 表需要耗费比较长的时间。\n\n### 反向查表破解\n这一招是针对同时破解大量用户的时候用的。\n一般的密码破解的本质是：对同一个用户名，用不同的密码去试，看看哪个是正确的。\n而反向查表的本质是：用一个密码去试所有用户，看看谁在用这个密码，一直换密码直到表里面所有的密码都试过了。\n\n这里用的表还是查表破解里经过了 hash 加密的密码表。\n\n### 彩虹表\n一种用时间换取了空间的表，牺牲了一些破解时间，以求表内包含的密码更全面。目前已经可以破解8位长度的任意 MD5 hash 。\n\n## 加盐\n各种查表的方法之所以有效，是因为 hash 函数的特性导致的，只要用户的密码相同，得到的 hash 值也一定相同。但是如果给每个人的密码加上一个随机的字符串再进行加密，那么即使两个用户使用了同一个密码，他们的密码存在数据库中的 hash 值也是不同的。\n这个随机的字符串就是盐（salt）。\n\n> 盐本身不需要保密，因为它的作用只是为了让各种表没那么容易生成。如果每次都要针对特定用户生成一个特定的表，那这个加盐的效果就达到了。\n\n## 参考资料\n* [加盐hash保存密码的正确方式](http://drops.wooyun.org/papers/1066)\n","slug":"hash-with-salt","published":1,"updated":"2016-04-26T09:19:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip56hb6n0005gr8fmbj5qi7d","content":"<p>又一篇学习笔记，这篇比较水，相当于是把原文给简化了一下，如果想要深入了解的话推荐还是看看原文<a href=\"http://drops.wooyun.org/papers/1066\" target=\"_blank\" rel=\"external\">加盐hash保存密码的正确方式</a>.</p>\n<p>基于 <a href=\"https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle\" target=\"_blank\" rel=\"external\">Kerckhoffs's principle</a>，我们需要一种没有人能“看懂”但是又可以被验证的密码系统，听起来非常矛盾，但是哈希算法恰好满足了这个要求，于是通过加盐 hash 保存密码的方式应该是市面上比较稳妥的做法了。\n在说明加盐是什么之前，先来看看它所使用到的 Hash 的作用和一些常见的密码破解手段，相信看完之后，”为什么要加盐”这个问题也就自然而然的解决了。</p>\n<a id=\"more\"></a>\n<h2>Hash</h2>\n<p>Hash 算法是一种单向的函数，它可以把任意数量的数据转换成固定长度的 <em>指纹</em>，这个过程是不可逆的，而且只要输入的数据中有一丝改变，结果的 hash 值也会有很大的不同。\n这里的 Hash 算法跟数据结构上的 hash 函数不完全相同，根据不同的使用场景，需要使用具有不同特性的 hash 函数。实现 hash 表的函数具有快速的特点，而加密 hash 函数是用来进行密码加密的，所以必须要确保安全性，比如 SHA256、SHA512、RipeMD、WHIRLPOOL。</p>\n<h2>一些常见的破解手段</h2>\n<h3>字典&amp;暴力破解</h3>\n<p>基本上一切密码都可以用这种途径来破解，只是时间长短的问题了。</p>\n<ul>\n<li>字典破解：根据所有能找到的常用密码，生成一个密码字典，然后遍历字典中的值，一个个去尝试</li>\n<li>暴力破解：对于给定长度的密码，尝试每一种可能的字符组合。</li>\n</ul>\n<p>既然没有办法阻止这种破解方式，那么只能让这种方式变得低效，从而达到花费时间不可接受的地步，让破解者主动放弃。</p>\n<h3>查表破解</h3>\n<p>其实就是密码破解的进阶版。将密码字典中的每一个密码的 hash 值预先计算出来，放到另一张表里，这样做可以加快配对的速度。缺点是建立这个 hash 表需要耗费比较长的时间。</p>\n<h3>反向查表破解</h3>\n<p>这一招是针对同时破解大量用户的时候用的。\n一般的密码破解的本质是：对同一个用户名，用不同的密码去试，看看哪个是正确的。\n而反向查表的本质是：用一个密码去试所有用户，看看谁在用这个密码，一直换密码直到表里面所有的密码都试过了。</p>\n<p>这里用的表还是查表破解里经过了 hash 加密的密码表。</p>\n<h3>彩虹表</h3>\n<p>一种用时间换取了空间的表，牺牲了一些破解时间，以求表内包含的密码更全面。目前已经可以破解8位长度的任意 MD5 hash 。</p>\n<h2>加盐</h2>\n<p>各种查表的方法之所以有效，是因为 hash 函数的特性导致的，只要用户的密码相同，得到的 hash 值也一定相同。但是如果给每个人的密码加上一个随机的字符串再进行加密，那么即使两个用户使用了同一个密码，他们的密码存在数据库中的 hash 值也是不同的。\n这个随机的字符串就是盐（salt）。</p>\n<blockquote>\n<p>盐本身不需要保密，因为它的作用只是为了让各种表没那么容易生成。如果每次都要针对特定用户生成一个特定的表，那这个加盐的效果就达到了。</p>\n</blockquote>\n<h2>参考资料</h2>\n<ul>\n<li><a href=\"http://drops.wooyun.org/papers/1066\" target=\"_blank\" rel=\"external\">加盐hash保存密码的正确方式</a></li>\n</ul>\n","excerpt":"<p>又一篇学习笔记，这篇比较水，相当于是把原文给简化了一下，如果想要深入了解的话推荐还是看看原文<a href=\"http://drops.wooyun.org/papers/1066\">加盐hash保存密码的正确方式</a>.</p>\n<p>基于 <a href=\"https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle\">Kerckhoffs's principle</a>，我们需要一种没有人能“看懂”但是又可以被验证的密码系统，听起来非常矛盾，但是哈希算法恰好满足了这个要求，于是通过加盐 hash 保存密码的方式应该是市面上比较稳妥的做法了。\n在说明加盐是什么之前，先来看看它所使用到的 Hash 的作用和一些常见的密码破解手段，相信看完之后，”为什么要加盐”这个问题也就自然而然的解决了。</p>","more":"<h2>Hash</h2>\n<p>Hash 算法是一种单向的函数，它可以把任意数量的数据转换成固定长度的 <em>指纹</em>，这个过程是不可逆的，而且只要输入的数据中有一丝改变，结果的 hash 值也会有很大的不同。\n这里的 Hash 算法跟数据结构上的 hash 函数不完全相同，根据不同的使用场景，需要使用具有不同特性的 hash 函数。实现 hash 表的函数具有快速的特点，而加密 hash 函数是用来进行密码加密的，所以必须要确保安全性，比如 SHA256、SHA512、RipeMD、WHIRLPOOL。</p>\n<h2>一些常见的破解手段</h2>\n<h3>字典&amp;暴力破解</h3>\n<p>基本上一切密码都可以用这种途径来破解，只是时间长短的问题了。</p>\n<ul>\n<li>字典破解：根据所有能找到的常用密码，生成一个密码字典，然后遍历字典中的值，一个个去尝试</li>\n<li>暴力破解：对于给定长度的密码，尝试每一种可能的字符组合。</li>\n</ul>\n<p>既然没有办法阻止这种破解方式，那么只能让这种方式变得低效，从而达到花费时间不可接受的地步，让破解者主动放弃。</p>\n<h3>查表破解</h3>\n<p>其实就是密码破解的进阶版。将密码字典中的每一个密码的 hash 值预先计算出来，放到另一张表里，这样做可以加快配对的速度。缺点是建立这个 hash 表需要耗费比较长的时间。</p>\n<h3>反向查表破解</h3>\n<p>这一招是针对同时破解大量用户的时候用的。\n一般的密码破解的本质是：对同一个用户名，用不同的密码去试，看看哪个是正确的。\n而反向查表的本质是：用一个密码去试所有用户，看看谁在用这个密码，一直换密码直到表里面所有的密码都试过了。</p>\n<p>这里用的表还是查表破解里经过了 hash 加密的密码表。</p>\n<h3>彩虹表</h3>\n<p>一种用时间换取了空间的表，牺牲了一些破解时间，以求表内包含的密码更全面。目前已经可以破解8位长度的任意 MD5 hash 。</p>\n<h2>加盐</h2>\n<p>各种查表的方法之所以有效，是因为 hash 函数的特性导致的，只要用户的密码相同，得到的 hash 值也一定相同。但是如果给每个人的密码加上一个随机的字符串再进行加密，那么即使两个用户使用了同一个密码，他们的密码存在数据库中的 hash 值也是不同的。\n这个随机的字符串就是盐（salt）。</p>\n<blockquote>\n<p>盐本身不需要保密，因为它的作用只是为了让各种表没那么容易生成。如果每次都要针对特定用户生成一个特定的表，那这个加盐的效果就达到了。</p>\n</blockquote>\n<h2>参考资料</h2>\n<ul>\n<li><a href=\"http://drops.wooyun.org/papers/1066\">加盐hash保存密码的正确方式</a></li>\n</ul>"},{"title":"iOS获取图片附加信息","date":"2016-04-21T06:17:35.000Z","_content":"\n为了提供更好的体验，iOS上的App通常都会在条件允许的情况下尽可能多地获取用户信息（说好的隐私呢？！）。比如说，在用户选取了相册中的某张图片后，自动补充图片的拍摄日期、时间、地点等等，给用户一个非常智能的感觉。当然，前提是用户给予了我们这样做的权限。\n\n<!-- more -->\n\n## 那么问题来了\n如何获得这些信息呢？\n\n稍微查一下可以知道，有一种叫做[EXIF](http://en.wikipedia.org/wiki/Exchangeable_image_file_format)(Exchangeable image file format)的东西可以用来在图片中保存一定的数据（像素、ISO等）。这种标准通常应用在数码相机上，在用户照相同时，默默把当前的日期和时间给记录下来。而如今的智能手机在这个基础上还加入了地理位置等信息，包装成了一大个MetaData，信息数据应有尽有，可谓是给各位开发者提供了大大的方便啊。\n\n可是，照片上的这些信息我们要怎样读取出来呢？\n\n## 前提\n首先你的这张照片一定要存有这些信息才能被读取出来吧？\n![focus](/uploads/iOS获取图片附加信息/focus.png)\n\n\n喂！这真的不是废话！\n\n虽然现在的手机已经非常智能了，但是可以照相的应用却是五花八门，并不是每一位开发者都会考虑那么多，有相当一部分应用不管这部分数据的“死活”，它们想要的只是那一张图片而已。\n\n所以，手机相册中的照片也不是百分百的带有我们想要的数据。有可能数据是完整的，但更多情况下，数据是残缺的，甚至完全没有这些数据。碰上这种情况，而你又迫切需要这些信息，那就只好求我们的用户大发慈悲地给我输入一下了。\n\n特殊情况，特殊处理，这里不处理...\n就先把我们的用户当成一个非常有耐心、对手机非常信任、照相时网络状况良好的上帝吧:)\n\n## 照片哪里来\n对于直接从照相机获取的照片来说，因为过程太短，所以并不能指望这张照片上面有多少我们想要的信息。如果条件允许的话，我们可以自己在后台采集（记录时间、定位等）。\n\n从相册里面拿出来的照片就好多了。因为照片有一个保存的过程，耗时相对比较长，该采集的信息也采集得差不多了，没采集的我们也没有什么办法，所以就在这些已有的数据上下功夫就好了。\n\n题外话：在用`UIImagePickerController`的时候，不小心遇到了一个问题，虽然和这篇文章的主题没有太大关系，不过我还是在[完整代码](https://github.com/davidleee/GetExifInfoDemo)里把解决方案写了下来。\n\n## 动手吧！\n用`UIImagePickerController`来获取相册照片的过程就不多说了，我们主要来看它的一个代理方法`-[imagePickerController:didFinishPickingMediaWithInfo:]`。\n\n这个代理方法会给我们一个字典info，如果用户选择的是一张图片的话，这个info里面除了有这张图片以外，还有图片的URL等信息。\n这张图片对我们接下来要做的事情作用不大，要关注的是这个URL。\n\n在继续之前，我们还要加入这两个库：（下面的代码其实不需要ImageIO库，看[完整代码](https://github.com/davidleee/GetExifInfoDemo)就知道怎么回事了）\n\n```objc\n#import <AssetsLibrary/AssetsLibrary.h>\n#import <ImageIO/ImageIO.h>\n```\n\n在UIImagePickerController.h里面，对这个info字典的key给出了定义：\n\n```objc\n// info dictionary keys\nUIKIT_EXTERN NSString *const UIImagePickerControllerMediaType;      // an NSString (UTI, i.e. kUTTypeImage)\nUIKIT_EXTERN NSString *const UIImagePickerControllerOriginalImage;  // a UIImage\nUIKIT_EXTERN NSString *const UIImagePickerControllerEditedImage;    // a UIImage\nUIKIT_EXTERN NSString *const UIImagePickerControllerCropRect;       // an NSValue (CGRect)\nUIKIT_EXTERN NSString *const UIImagePickerControllerMediaURL;       // an NSURL\nUIKIT_EXTERN NSString *const UIImagePickerControllerReferenceURL        NS_AVAILABLE_IOS(4_1);  // an NSURL that references an asset in the AssetsLibrary framework\nUIKIT_EXTERN NSString *const UIImagePickerControllerMediaMetadata       NS_AVAILABLE_IOS(4_1);  // an NSDictionary containing metadata from a captured photo\n```\n\n而我们需要的只有`UIImagePickerControllerReferenceURL`对应的值。\n\n因为UIKit都已经帮我们封装好了，所以真正要做的只剩下很少一部分。\n起作用的代码就只有下面这几行：\n\n```objc\nALAssetsLibrary *library = [[ALAssetsLibrary alloc] init]; // 1\n[library assetForURL:[info objectForKey:UIImagePickerControllerReferenceURL] resultBlock:^(ALAsset *asset) { // 2\n\n    NSDictionary *imageInfo = [asset defaultRepresentation].metadata;\n\n} failureBlock:^(NSError *error) {\n\n    ...\n\n}];\n```\n\n这里做了什么呢？\n\n1. 初始化了一个`ALAssetsLibrary`，可以把它想象成当前应用与系统相册之间的一个通道，通过它我们就可以对系统的相册进行一定程度上的数据存取；\n2. 根据`UIImagePickerController`提供的URL，找到这张照片在相册中对应的对象（ALAsset），并返回给我们操作。\n\n剩下的事情就一目了然了，metadata就是我们想要的数据字典。\n\n## 结语\n读取照片中的信息并没有我们想象中的复杂，网上有许多实现用到了一些更底层的方法，我在代码里也有写下来。更完整的叙述可以看Stackoverflow上的[这个回答](http://stackoverflow.com/a/9767129/4177374)。\n\n<br/>\n[完整代码传送门](https://github.com/davidleee/GetExifInfoDemo)\n","source":"_posts/get-exif-from-image-ios.md","raw":"---\ntitle: iOS获取图片附加信息\ndate: 2016-04-21 14:17:35\ntags:\n- iOS\n- Exif\n---\n\n为了提供更好的体验，iOS上的App通常都会在条件允许的情况下尽可能多地获取用户信息（说好的隐私呢？！）。比如说，在用户选取了相册中的某张图片后，自动补充图片的拍摄日期、时间、地点等等，给用户一个非常智能的感觉。当然，前提是用户给予了我们这样做的权限。\n\n<!-- more -->\n\n## 那么问题来了\n如何获得这些信息呢？\n\n稍微查一下可以知道，有一种叫做[EXIF](http://en.wikipedia.org/wiki/Exchangeable_image_file_format)(Exchangeable image file format)的东西可以用来在图片中保存一定的数据（像素、ISO等）。这种标准通常应用在数码相机上，在用户照相同时，默默把当前的日期和时间给记录下来。而如今的智能手机在这个基础上还加入了地理位置等信息，包装成了一大个MetaData，信息数据应有尽有，可谓是给各位开发者提供了大大的方便啊。\n\n可是，照片上的这些信息我们要怎样读取出来呢？\n\n## 前提\n首先你的这张照片一定要存有这些信息才能被读取出来吧？\n![focus](/uploads/iOS获取图片附加信息/focus.png)\n\n\n喂！这真的不是废话！\n\n虽然现在的手机已经非常智能了，但是可以照相的应用却是五花八门，并不是每一位开发者都会考虑那么多，有相当一部分应用不管这部分数据的“死活”，它们想要的只是那一张图片而已。\n\n所以，手机相册中的照片也不是百分百的带有我们想要的数据。有可能数据是完整的，但更多情况下，数据是残缺的，甚至完全没有这些数据。碰上这种情况，而你又迫切需要这些信息，那就只好求我们的用户大发慈悲地给我输入一下了。\n\n特殊情况，特殊处理，这里不处理...\n就先把我们的用户当成一个非常有耐心、对手机非常信任、照相时网络状况良好的上帝吧:)\n\n## 照片哪里来\n对于直接从照相机获取的照片来说，因为过程太短，所以并不能指望这张照片上面有多少我们想要的信息。如果条件允许的话，我们可以自己在后台采集（记录时间、定位等）。\n\n从相册里面拿出来的照片就好多了。因为照片有一个保存的过程，耗时相对比较长，该采集的信息也采集得差不多了，没采集的我们也没有什么办法，所以就在这些已有的数据上下功夫就好了。\n\n题外话：在用`UIImagePickerController`的时候，不小心遇到了一个问题，虽然和这篇文章的主题没有太大关系，不过我还是在[完整代码](https://github.com/davidleee/GetExifInfoDemo)里把解决方案写了下来。\n\n## 动手吧！\n用`UIImagePickerController`来获取相册照片的过程就不多说了，我们主要来看它的一个代理方法`-[imagePickerController:didFinishPickingMediaWithInfo:]`。\n\n这个代理方法会给我们一个字典info，如果用户选择的是一张图片的话，这个info里面除了有这张图片以外，还有图片的URL等信息。\n这张图片对我们接下来要做的事情作用不大，要关注的是这个URL。\n\n在继续之前，我们还要加入这两个库：（下面的代码其实不需要ImageIO库，看[完整代码](https://github.com/davidleee/GetExifInfoDemo)就知道怎么回事了）\n\n```objc\n#import <AssetsLibrary/AssetsLibrary.h>\n#import <ImageIO/ImageIO.h>\n```\n\n在UIImagePickerController.h里面，对这个info字典的key给出了定义：\n\n```objc\n// info dictionary keys\nUIKIT_EXTERN NSString *const UIImagePickerControllerMediaType;      // an NSString (UTI, i.e. kUTTypeImage)\nUIKIT_EXTERN NSString *const UIImagePickerControllerOriginalImage;  // a UIImage\nUIKIT_EXTERN NSString *const UIImagePickerControllerEditedImage;    // a UIImage\nUIKIT_EXTERN NSString *const UIImagePickerControllerCropRect;       // an NSValue (CGRect)\nUIKIT_EXTERN NSString *const UIImagePickerControllerMediaURL;       // an NSURL\nUIKIT_EXTERN NSString *const UIImagePickerControllerReferenceURL        NS_AVAILABLE_IOS(4_1);  // an NSURL that references an asset in the AssetsLibrary framework\nUIKIT_EXTERN NSString *const UIImagePickerControllerMediaMetadata       NS_AVAILABLE_IOS(4_1);  // an NSDictionary containing metadata from a captured photo\n```\n\n而我们需要的只有`UIImagePickerControllerReferenceURL`对应的值。\n\n因为UIKit都已经帮我们封装好了，所以真正要做的只剩下很少一部分。\n起作用的代码就只有下面这几行：\n\n```objc\nALAssetsLibrary *library = [[ALAssetsLibrary alloc] init]; // 1\n[library assetForURL:[info objectForKey:UIImagePickerControllerReferenceURL] resultBlock:^(ALAsset *asset) { // 2\n\n    NSDictionary *imageInfo = [asset defaultRepresentation].metadata;\n\n} failureBlock:^(NSError *error) {\n\n    ...\n\n}];\n```\n\n这里做了什么呢？\n\n1. 初始化了一个`ALAssetsLibrary`，可以把它想象成当前应用与系统相册之间的一个通道，通过它我们就可以对系统的相册进行一定程度上的数据存取；\n2. 根据`UIImagePickerController`提供的URL，找到这张照片在相册中对应的对象（ALAsset），并返回给我们操作。\n\n剩下的事情就一目了然了，metadata就是我们想要的数据字典。\n\n## 结语\n读取照片中的信息并没有我们想象中的复杂，网上有许多实现用到了一些更底层的方法，我在代码里也有写下来。更完整的叙述可以看Stackoverflow上的[这个回答](http://stackoverflow.com/a/9767129/4177374)。\n\n<br/>\n[完整代码传送门](https://github.com/davidleee/GetExifInfoDemo)\n","slug":"get-exif-from-image-ios","published":1,"updated":"2016-04-26T09:18:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip56hb6q0006gr8f2dsknloy","content":"<p>为了提供更好的体验，iOS上的App通常都会在条件允许的情况下尽可能多地获取用户信息（说好的隐私呢？！）。比如说，在用户选取了相册中的某张图片后，自动补充图片的拍摄日期、时间、地点等等，给用户一个非常智能的感觉。当然，前提是用户给予了我们这样做的权限。</p>\n<a id=\"more\"></a>\n<h2>那么问题来了</h2>\n<p>如何获得这些信息呢？</p>\n<p>稍微查一下可以知道，有一种叫做<a href=\"http://en.wikipedia.org/wiki/Exchangeable_image_file_format\" target=\"_blank\" rel=\"external\">EXIF</a>(Exchangeable image file format)的东西可以用来在图片中保存一定的数据（像素、ISO等）。这种标准通常应用在数码相机上，在用户照相同时，默默把当前的日期和时间给记录下来。而如今的智能手机在这个基础上还加入了地理位置等信息，包装成了一大个MetaData，信息数据应有尽有，可谓是给各位开发者提供了大大的方便啊。</p>\n<p>可是，照片上的这些信息我们要怎样读取出来呢？</p>\n<h2>前提</h2>\n<p>首先你的这张照片一定要存有这些信息才能被读取出来吧？\n<img src=\"/uploads/iOS%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF/focus.png\" alt=\"focus\"></p>\n<p>喂！这真的不是废话！</p>\n<p>虽然现在的手机已经非常智能了，但是可以照相的应用却是五花八门，并不是每一位开发者都会考虑那么多，有相当一部分应用不管这部分数据的“死活”，它们想要的只是那一张图片而已。</p>\n<p>所以，手机相册中的照片也不是百分百的带有我们想要的数据。有可能数据是完整的，但更多情况下，数据是残缺的，甚至完全没有这些数据。碰上这种情况，而你又迫切需要这些信息，那就只好求我们的用户大发慈悲地给我输入一下了。</p>\n<p>特殊情况，特殊处理，这里不处理...\n就先把我们的用户当成一个非常有耐心、对手机非常信任、照相时网络状况良好的上帝吧:)</p>\n<h2>照片哪里来</h2>\n<p>对于直接从照相机获取的照片来说，因为过程太短，所以并不能指望这张照片上面有多少我们想要的信息。如果条件允许的话，我们可以自己在后台采集（记录时间、定位等）。</p>\n<p>从相册里面拿出来的照片就好多了。因为照片有一个保存的过程，耗时相对比较长，该采集的信息也采集得差不多了，没采集的我们也没有什么办法，所以就在这些已有的数据上下功夫就好了。</p>\n<p>题外话：在用<code>UIImagePickerController</code>的时候，不小心遇到了一个问题，虽然和这篇文章的主题没有太大关系，不过我还是在<a href=\"https://github.com/davidleee/GetExifInfoDemo\" target=\"_blank\" rel=\"external\">完整代码</a>里把解决方案写了下来。</p>\n<h2>动手吧！</h2>\n<p>用<code>UIImagePickerController</code>来获取相册照片的过程就不多说了，我们主要来看它的一个代理方法<code>-[imagePickerController:didFinishPickingMediaWithInfo:]</code>。</p>\n<p>这个代理方法会给我们一个字典info，如果用户选择的是一张图片的话，这个info里面除了有这张图片以外，还有图片的URL等信息。\n这张图片对我们接下来要做的事情作用不大，要关注的是这个URL。</p>\n<p>在继续之前，我们还要加入这两个库：（下面的代码其实不需要ImageIO库，看<a href=\"https://github.com/davidleee/GetExifInfoDemo\" target=\"_blank\" rel=\"external\">完整代码</a>就知道怎么回事了）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;AssetsLibrary/AssetsLibrary.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;ImageIO/ImageIO.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>在UIImagePickerController.h里面，对这个info字典的key给出了定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// info dictionary keys</span></span><br><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIImagePickerControllerMediaType</span>;      <span class=\"comment\">// an NSString (UTI, i.e. kUTTypeImage)</span></span><br><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIImagePickerControllerOriginalImage</span>;  <span class=\"comment\">// a UIImage</span></span><br><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIImagePickerControllerEditedImage</span>;    <span class=\"comment\">// a UIImage</span></span><br><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIImagePickerControllerCropRect</span>;       <span class=\"comment\">// an NSValue (CGRect)</span></span><br><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIImagePickerControllerMediaURL</span>;       <span class=\"comment\">// an NSURL</span></span><br><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIImagePickerControllerReferenceURL</span>        <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">4</span>_1);  <span class=\"comment\">// an NSURL that references an asset in the AssetsLibrary framework</span></span><br><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIImagePickerControllerMediaMetadata</span>       <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">4</span>_1);  <span class=\"comment\">// an NSDictionary containing metadata from a captured photo</span></span><br></pre></td></tr></table></figure>\n<p>而我们需要的只有<code>UIImagePickerControllerReferenceURL</code>对应的值。</p>\n<p>因为UIKit都已经帮我们封装好了，所以真正要做的只剩下很少一部分。\n起作用的代码就只有下面这几行：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init]; <span class=\"comment\">// 1</span></span><br><span class=\"line\">[library assetForURL:[info objectForKey:<span class=\"built_in\">UIImagePickerControllerReferenceURL</span>] resultBlock:^(ALAsset *asset) &#123; <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *imageInfo = [asset defaultRepresentation].metadata;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; failureBlock:^(<span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>这里做了什么呢？</p>\n<ol>\n<li>初始化了一个<code>ALAssetsLibrary</code>，可以把它想象成当前应用与系统相册之间的一个通道，通过它我们就可以对系统的相册进行一定程度上的数据存取；</li>\n<li>根据<code>UIImagePickerController</code>提供的URL，找到这张照片在相册中对应的对象（ALAsset），并返回给我们操作。</li>\n</ol>\n<p>剩下的事情就一目了然了，metadata就是我们想要的数据字典。</p>\n<h2>结语</h2>\n<p>读取照片中的信息并没有我们想象中的复杂，网上有许多实现用到了一些更底层的方法，我在代码里也有写下来。更完整的叙述可以看Stackoverflow上的<a href=\"http://stackoverflow.com/a/9767129/4177374\" target=\"_blank\" rel=\"external\">这个回答</a>。</p>\n<br>\n[完整代码传送门](https://github.com/davidleee/GetExifInfoDemo)\n","excerpt":"<p>为了提供更好的体验，iOS上的App通常都会在条件允许的情况下尽可能多地获取用户信息（说好的隐私呢？！）。比如说，在用户选取了相册中的某张图片后，自动补充图片的拍摄日期、时间、地点等等，给用户一个非常智能的感觉。当然，前提是用户给予了我们这样做的权限。</p>","more":"<h2>那么问题来了</h2>\n<p>如何获得这些信息呢？</p>\n<p>稍微查一下可以知道，有一种叫做<a href=\"http://en.wikipedia.org/wiki/Exchangeable_image_file_format\">EXIF</a>(Exchangeable image file format)的东西可以用来在图片中保存一定的数据（像素、ISO等）。这种标准通常应用在数码相机上，在用户照相同时，默默把当前的日期和时间给记录下来。而如今的智能手机在这个基础上还加入了地理位置等信息，包装成了一大个MetaData，信息数据应有尽有，可谓是给各位开发者提供了大大的方便啊。</p>\n<p>可是，照片上的这些信息我们要怎样读取出来呢？</p>\n<h2>前提</h2>\n<p>首先你的这张照片一定要存有这些信息才能被读取出来吧？\n<img src=\"/uploads/iOS%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF/focus.png\" alt=\"focus\"></p>\n<p>喂！这真的不是废话！</p>\n<p>虽然现在的手机已经非常智能了，但是可以照相的应用却是五花八门，并不是每一位开发者都会考虑那么多，有相当一部分应用不管这部分数据的“死活”，它们想要的只是那一张图片而已。</p>\n<p>所以，手机相册中的照片也不是百分百的带有我们想要的数据。有可能数据是完整的，但更多情况下，数据是残缺的，甚至完全没有这些数据。碰上这种情况，而你又迫切需要这些信息，那就只好求我们的用户大发慈悲地给我输入一下了。</p>\n<p>特殊情况，特殊处理，这里不处理...\n就先把我们的用户当成一个非常有耐心、对手机非常信任、照相时网络状况良好的上帝吧:)</p>\n<h2>照片哪里来</h2>\n<p>对于直接从照相机获取的照片来说，因为过程太短，所以并不能指望这张照片上面有多少我们想要的信息。如果条件允许的话，我们可以自己在后台采集（记录时间、定位等）。</p>\n<p>从相册里面拿出来的照片就好多了。因为照片有一个保存的过程，耗时相对比较长，该采集的信息也采集得差不多了，没采集的我们也没有什么办法，所以就在这些已有的数据上下功夫就好了。</p>\n<p>题外话：在用<code>UIImagePickerController</code>的时候，不小心遇到了一个问题，虽然和这篇文章的主题没有太大关系，不过我还是在<a href=\"https://github.com/davidleee/GetExifInfoDemo\">完整代码</a>里把解决方案写了下来。</p>\n<h2>动手吧！</h2>\n<p>用<code>UIImagePickerController</code>来获取相册照片的过程就不多说了，我们主要来看它的一个代理方法<code>-[imagePickerController:didFinishPickingMediaWithInfo:]</code>。</p>\n<p>这个代理方法会给我们一个字典info，如果用户选择的是一张图片的话，这个info里面除了有这张图片以外，还有图片的URL等信息。\n这张图片对我们接下来要做的事情作用不大，要关注的是这个URL。</p>\n<p>在继续之前，我们还要加入这两个库：（下面的代码其实不需要ImageIO库，看<a href=\"https://github.com/davidleee/GetExifInfoDemo\">完整代码</a>就知道怎么回事了）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;AssetsLibrary/AssetsLibrary.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;ImageIO/ImageIO.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>在UIImagePickerController.h里面，对这个info字典的key给出了定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// info dictionary keys</span></span><br><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIImagePickerControllerMediaType</span>;      <span class=\"comment\">// an NSString (UTI, i.e. kUTTypeImage)</span></span><br><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIImagePickerControllerOriginalImage</span>;  <span class=\"comment\">// a UIImage</span></span><br><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIImagePickerControllerEditedImage</span>;    <span class=\"comment\">// a UIImage</span></span><br><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIImagePickerControllerCropRect</span>;       <span class=\"comment\">// an NSValue (CGRect)</span></span><br><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIImagePickerControllerMediaURL</span>;       <span class=\"comment\">// an NSURL</span></span><br><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIImagePickerControllerReferenceURL</span>        <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">4</span>_1);  <span class=\"comment\">// an NSURL that references an asset in the AssetsLibrary framework</span></span><br><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIImagePickerControllerMediaMetadata</span>       <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">4</span>_1);  <span class=\"comment\">// an NSDictionary containing metadata from a captured photo</span></span><br></pre></td></tr></table></figure>\n<p>而我们需要的只有<code>UIImagePickerControllerReferenceURL</code>对应的值。</p>\n<p>因为UIKit都已经帮我们封装好了，所以真正要做的只剩下很少一部分。\n起作用的代码就只有下面这几行：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init]; <span class=\"comment\">// 1</span></span><br><span class=\"line\">[library assetForURL:[info objectForKey:<span class=\"built_in\">UIImagePickerControllerReferenceURL</span>] resultBlock:^(ALAsset *asset) &#123; <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *imageInfo = [asset defaultRepresentation].metadata;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; failureBlock:^(<span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>这里做了什么呢？</p>\n<ol>\n<li>初始化了一个<code>ALAssetsLibrary</code>，可以把它想象成当前应用与系统相册之间的一个通道，通过它我们就可以对系统的相册进行一定程度上的数据存取；</li>\n<li>根据<code>UIImagePickerController</code>提供的URL，找到这张照片在相册中对应的对象（ALAsset），并返回给我们操作。</li>\n</ol>\n<p>剩下的事情就一目了然了，metadata就是我们想要的数据字典。</p>\n<h2>结语</h2>\n<p>读取照片中的信息并没有我们想象中的复杂，网上有许多实现用到了一些更底层的方法，我在代码里也有写下来。更完整的叙述可以看Stackoverflow上的<a href=\"http://stackoverflow.com/a/9767129/4177374\">这个回答</a>。</p>\n<br/>\n[完整代码传送门](https://github.com/davidleee/GetExifInfoDemo)"},{"title":"简易 Core Data 入门","date":"2016-05-09T01:59:27.000Z","_content":"\n也不知道是我搜索的方法不对还是别的什么问题，网络上很少见 Core Data 的入门教程，所以这篇东西就这样定位了：比看官方文档轻松得多，却可以马上在自己的 App 里用上 Core Data。\n不求深入到可以拿出去显摆，但是起码要可以用上手，并且能分享一篇入门指南，就像现在这样:)\n\n<!-- more -->\n\n## Launch our Xcode!\n不管怎么样，先把咱熟悉的 Xcode 召唤起来，创建一个新项目。本项目的完整代码可以在[这里](https://github.com/davidleee/CoreDataTryout)找到。对了，创建项目的时候记得把下面这个小勾给勾上，让 Xcode 帮我们创建模型文件。\n![use_core_data](/uploads/easy-core-data/use_core_data.png)￼\n\n然后就可以看到项目中出现一个后缀为 xcdatamodeld 的文件，这个文件相当于 Core Data 的 storyboard （不知道 [storyboard](https://developer.apple.com/videos/wwdc/2012/?id=407)？）。选中它，你会看到这样几个东西：\n![model_document](/uploads/easy-core-data/model_document.png)￼\n\n在这篇文章里，我们就只关注 Entities 部分。\n\n## 浅入浅出\n想要详细了解 Core Data 里面的结构关系的话，可以去翻翻[官方文档](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/cdProgrammingGuide.html#//apple_ref/doc/uid/TP40001075)。但是一开始接触的时候，不外乎就是这么几个类：\n\n* NSManagedObjectModel\n\n这玩意儿是什么呢？说白了，你可以认为它就是我们的 xcdatamodeld 。它包含了我们自己定义的实体( Entitiy )、实体内部的属性( Attribute )和实体之间的关系( Relationship )，就像是我们在设计数据库的时候画的E-R图。原则上，这个模型越是完善，你的 App 对 Core Data 的支持就越好。\n\n* NSManagedObjectContext\n\n按照官方文档的[说法](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdBasics.html#//apple_ref/doc/uid/TP40001650-SW3)，`NSManagedObjectContext` 就像是一个智能的工作台。当你想从数据库中获取数据的时候，这些数据会被暂时复制一份到这个工作台上，然后你就可以对它们进行操作了。这样，除非你确实进行了一次保存，否则数据库里的真实数据是不会被改变的。\n\n而在实际使用中，我们最频繁接触的也是这个 `NSManagedObjectContext`。\n\n* NSPersistentStoreCoordinator\n\n从名字大概可以猜到，这个类是不同数据库存储之间的协调者。\n\n在 App 里面创建出来的数据对象和实际保存着的数据之间，存在着一个持久栈( Persistence Stack )。这个栈的最顶层是 `NSManagedObjectContext`，而它的最底层则是一个个数据文件( Persistent Object Store )，在它们之间的就是 `NSPersistentStoreCoordinator`。我们因为 `NSManagedObjectContext`的存在，而不需要直接操作这些数据文件；而且 Persistent Store Coordinator 的存在，是基于外观模式的设计，这就使得 `NSManagedObjectContext` 不需要面对多个数据文件，只和 Coordinator 打交道就可以了。\n\n整个持久栈看起来就是这个样子：\n￼{% img [persistence_stack] /uploads/easy-core-data/persistence_stack.png  Persistence Stack %}\n\n好，铺垫了那么久，也该用实践来检验一下真理了。\n\n## 准备工作\n什么？上面讲了那么久的三个东西，Xcode 已经帮我们在 AppDelegate 里都准备好了？\n嗯，没错，很贴心嘛。\n￼{% img [r_u_kidding] /uploads/easy-core-data/r_u_kidding.png  250 250 %}\n\n不过我们还是来简单理一理这些代码里面的关系吧。\n\n可以发现，这几个对象的创建顺序是这样的 NSManagedObjectModel -> NSPersistentStoreCoordinator -> NSManagedObjectContext，跟持久栈的关系很一致。\n不过在此之前，我们还是需要拿到我们的 xcdatamodeld 才可以创建我们的模型：\n\n```objc\n\tNSURL *modelURL = [[NSBundle mainBundle] URLForResource:@\"CoreDataTryout\" withExtension:@\"momd\"];\n\t_managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];\n```\n\n然后用这个模型来创建 `NSPersistentStoreCoordinator`：\n\n```objc\n\t_persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]];\n  NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@\"CoreDataTryout.sqlite\"];\n\n  ...\n\n  if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&error]) {...}\n```\n\n程序会在 App 的 document 目录中创建一个名为 CoreDataTryout.sqlite 的文件，`NSSQLiteStoreType` 是我们选择的数据库类型，我们还可以选择 XML（ iOS 上不支持）、Atomic 或者 In-Memory，如果这些类型你都不喜欢，你还可以创建[自定义存储类型](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdPersistentStores.html#//apple_ref/doc/uid/TP40002875-SW6)。\n\n最后，在 `managedObjectContext` 的 setter 里面，我们给它装上准备好的 `persistentStoreCoordinator` 就大功告成了：\n\n```objc\n  _managedObjectContext = [[NSManagedObjectContext alloc] init];\n  [_managedObjectContext setPersistentStoreCoordinator:coordinator];\n```\n\n注意到在 `application:didFinishLaunchingWithOptions:` 的最后还调用了一个 `saveContext` 方法。\n\nCore Data 里面的数据都是自动保存的，也就是说，你完全可以在代码里把实体的对象创建出来，乱改一通，然后留下一个帅气的背影，奔向下一段代码。\n `managedObjectContext` 在发现有数据被改动了之后，会在一个*合适的时机*保存这些更改。这个保存也许不是数据变化后马上进行的，但是也足够智能可以让我们免去时不时保存一下的烦恼。有些时候（比如你暂停了你运行中的程序） `managedObjectContext` 会来不及做这些工作，或者你想要确保当下的数据被写进了数据库里，那么这个 `saveContext` 就会派上用场了。\n\n## 创建实体\n一切准备就绪，我们终于要真正开始操作我们的数据库了！\n\n先在我们的 xcdatamodeld 文件里面添加一个 Entity ，随便起个名字叫 User 好了，然后在右边 Attributes 那一栏里面添加一些属性。\n![attributes](/uploads/easy-core-data/attributes.png)￼\n\n\nAttributes 都是强类型的，所以如果你不手动给它们指定类型，编译器就会直接报错。能够写入数据库的类型还是挺丰富的，值得一提的是，数字和布尔值最终都会被转换成 `NSNumber` 来处理，而图片这一类比较大的文件就必须转换成 `NSData` 再写入了。\n\n接下来，让 Xcode 帮我们生成这个实体的子类：\n![create_subclasses](/uploads/easy-core-data/create_subclasses.png)￼\n\n\n选择一下 Model 和想要子类化的 Entity （有的项目会使用多个 Model，我们这里就只有一个）：\n![choose_mode](/uploads/easy-core-data/choose_model.png)￼\n![choose_entity](/uploads/easy-core-data/choose_entity.png)￼\n\n\n然后点 create ，你会发现项目文件夹中多两个文件 User.h/m。这两个文件由 Xcode 生成也由 Xcode 管理，所以如果我们改动了里面的内容，Xcode 可能就会跟我们发牢骚了。（如果确实需要添加某些功能，可以使用 category ）\n\n如今这个类已经全权代表了我们在模型里面创建的实体，它的 property 和我们添加的 attributes 是一一对应的关系，也就是可以直接从这些属性访问到实体的变量了。\n\n多说无益，赶紧来动动手！\n{% img [accept_challenge] /uploads/easy-core-data/accept_challenge.png 250 250 %}\n\n## Write the code, change the world!\n首先拉一个简陋的界面出来给我们的用户输入信息，下面放一个输出信息的地方，省的我们每次都跑到 Debug Area 里面看：\n{% img [main_v] /uploads/easy-core-data/main_vc.png Main VC %}\n\n\n把所有控件都 hook 起来，然后在“写进去”和\"读出来\"两个按钮的 IBAction 里写代码。\n首先把数据写进数据库：\n\n```objc\n\t- (IBAction)writeAction:(id)sender\n\t{\n\t    AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];\n\t    NSManagedObjectContext *context = appDelegate.managedObjectContext;\n\n\t    User *newUser = [NSEntityDescription insertNewObjectForEntityForName:@\"User\" inManagedObjectContext:context];\n\t    newUser.name = self.nameTextField.text;\n\t    newUser.age = @([self.ageTextField.text intValue]);\n\t    newUser.height = @([self.heightTextField.text intValue]);\n\t    newUser.weight = @([self.weightTextField.text intValue]);\n\n\t//    [context save:NULL];\n\t}\n```\n\nCore Data 用起来还是挺直观的吧？\n我们从 AppDelegate 里面拿到了老早就创建好了的 `managedObjectContext`，通过 `NSEntityDescription` 新建了一个准备插入到数据库中的 User；\n然后把用户输入的数据填充到 User 里面，保存一下。\n\n等等！ Core Data 是会自动保存的，所以最后一句注释掉也没有影响咯。\n\n接下来是读取数据：\n\n```objc\n\t- (IBAction)readAction:(id)sender\n\t{\n\t    AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];\n\t    NSManagedObjectContext *context = appDelegate.managedObjectContext;\n\n\t    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] initWithEntityName:@\"User\"];\n\t    NSError *error;\n\t    NSArray *results = [context executeFetchRequest:fetchRequest error:&error];\n\t    if ([results count]) {\n\t        self.consoleTextView.text = [results description];\n\t    } else {\n\t        self.consoleTextView.text = [error localizedDescription];\n\t    }\n\t}\n```\n\n认识一个新伙伴—— `NSFetchRequest`，数据库的读取基本都是靠这家伙了，你还可以对它加上各式各样的条件和约束，进行更精确的数据库查询。查询的结果会保存在一个 NSArray 里面，不管它，直接输出给我们看看。\n\n这就够了！让我们的程序跑起来吧！\n￼{% img [let_run] /uploads/easy-core-data/let_run.png  250 250 %}\n\n## 结果\n随便录入点数据，按下“写进去”，嗯，和预期的一样，什么反应也没有。\n然后按下\"读出来\"：\n<figure>\n{% img [result] /uploads/easy-core-data/result.png Result %}\n</figure>\n\n嗯？输出的结果看起来有点奇怪？\n那是因为我们直接把数组的 description 打印了出来。这个数组里面其实就是我们之前创建好的 User 对象，直接拿出来当Model用就可以了。\n","source":"_posts/easy-core-data.md","raw":"---\ntitle: 简易 Core Data 入门\ndate: 2016-05-09 09:59:27\ntags:\n- iOS\n- Core Data\n---\n\n也不知道是我搜索的方法不对还是别的什么问题，网络上很少见 Core Data 的入门教程，所以这篇东西就这样定位了：比看官方文档轻松得多，却可以马上在自己的 App 里用上 Core Data。\n不求深入到可以拿出去显摆，但是起码要可以用上手，并且能分享一篇入门指南，就像现在这样:)\n\n<!-- more -->\n\n## Launch our Xcode!\n不管怎么样，先把咱熟悉的 Xcode 召唤起来，创建一个新项目。本项目的完整代码可以在[这里](https://github.com/davidleee/CoreDataTryout)找到。对了，创建项目的时候记得把下面这个小勾给勾上，让 Xcode 帮我们创建模型文件。\n![use_core_data](/uploads/easy-core-data/use_core_data.png)￼\n\n然后就可以看到项目中出现一个后缀为 xcdatamodeld 的文件，这个文件相当于 Core Data 的 storyboard （不知道 [storyboard](https://developer.apple.com/videos/wwdc/2012/?id=407)？）。选中它，你会看到这样几个东西：\n![model_document](/uploads/easy-core-data/model_document.png)￼\n\n在这篇文章里，我们就只关注 Entities 部分。\n\n## 浅入浅出\n想要详细了解 Core Data 里面的结构关系的话，可以去翻翻[官方文档](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/cdProgrammingGuide.html#//apple_ref/doc/uid/TP40001075)。但是一开始接触的时候，不外乎就是这么几个类：\n\n* NSManagedObjectModel\n\n这玩意儿是什么呢？说白了，你可以认为它就是我们的 xcdatamodeld 。它包含了我们自己定义的实体( Entitiy )、实体内部的属性( Attribute )和实体之间的关系( Relationship )，就像是我们在设计数据库的时候画的E-R图。原则上，这个模型越是完善，你的 App 对 Core Data 的支持就越好。\n\n* NSManagedObjectContext\n\n按照官方文档的[说法](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdBasics.html#//apple_ref/doc/uid/TP40001650-SW3)，`NSManagedObjectContext` 就像是一个智能的工作台。当你想从数据库中获取数据的时候，这些数据会被暂时复制一份到这个工作台上，然后你就可以对它们进行操作了。这样，除非你确实进行了一次保存，否则数据库里的真实数据是不会被改变的。\n\n而在实际使用中，我们最频繁接触的也是这个 `NSManagedObjectContext`。\n\n* NSPersistentStoreCoordinator\n\n从名字大概可以猜到，这个类是不同数据库存储之间的协调者。\n\n在 App 里面创建出来的数据对象和实际保存着的数据之间，存在着一个持久栈( Persistence Stack )。这个栈的最顶层是 `NSManagedObjectContext`，而它的最底层则是一个个数据文件( Persistent Object Store )，在它们之间的就是 `NSPersistentStoreCoordinator`。我们因为 `NSManagedObjectContext`的存在，而不需要直接操作这些数据文件；而且 Persistent Store Coordinator 的存在，是基于外观模式的设计，这就使得 `NSManagedObjectContext` 不需要面对多个数据文件，只和 Coordinator 打交道就可以了。\n\n整个持久栈看起来就是这个样子：\n￼{% img [persistence_stack] /uploads/easy-core-data/persistence_stack.png  Persistence Stack %}\n\n好，铺垫了那么久，也该用实践来检验一下真理了。\n\n## 准备工作\n什么？上面讲了那么久的三个东西，Xcode 已经帮我们在 AppDelegate 里都准备好了？\n嗯，没错，很贴心嘛。\n￼{% img [r_u_kidding] /uploads/easy-core-data/r_u_kidding.png  250 250 %}\n\n不过我们还是来简单理一理这些代码里面的关系吧。\n\n可以发现，这几个对象的创建顺序是这样的 NSManagedObjectModel -> NSPersistentStoreCoordinator -> NSManagedObjectContext，跟持久栈的关系很一致。\n不过在此之前，我们还是需要拿到我们的 xcdatamodeld 才可以创建我们的模型：\n\n```objc\n\tNSURL *modelURL = [[NSBundle mainBundle] URLForResource:@\"CoreDataTryout\" withExtension:@\"momd\"];\n\t_managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];\n```\n\n然后用这个模型来创建 `NSPersistentStoreCoordinator`：\n\n```objc\n\t_persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]];\n  NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@\"CoreDataTryout.sqlite\"];\n\n  ...\n\n  if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&error]) {...}\n```\n\n程序会在 App 的 document 目录中创建一个名为 CoreDataTryout.sqlite 的文件，`NSSQLiteStoreType` 是我们选择的数据库类型，我们还可以选择 XML（ iOS 上不支持）、Atomic 或者 In-Memory，如果这些类型你都不喜欢，你还可以创建[自定义存储类型](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdPersistentStores.html#//apple_ref/doc/uid/TP40002875-SW6)。\n\n最后，在 `managedObjectContext` 的 setter 里面，我们给它装上准备好的 `persistentStoreCoordinator` 就大功告成了：\n\n```objc\n  _managedObjectContext = [[NSManagedObjectContext alloc] init];\n  [_managedObjectContext setPersistentStoreCoordinator:coordinator];\n```\n\n注意到在 `application:didFinishLaunchingWithOptions:` 的最后还调用了一个 `saveContext` 方法。\n\nCore Data 里面的数据都是自动保存的，也就是说，你完全可以在代码里把实体的对象创建出来，乱改一通，然后留下一个帅气的背影，奔向下一段代码。\n `managedObjectContext` 在发现有数据被改动了之后，会在一个*合适的时机*保存这些更改。这个保存也许不是数据变化后马上进行的，但是也足够智能可以让我们免去时不时保存一下的烦恼。有些时候（比如你暂停了你运行中的程序） `managedObjectContext` 会来不及做这些工作，或者你想要确保当下的数据被写进了数据库里，那么这个 `saveContext` 就会派上用场了。\n\n## 创建实体\n一切准备就绪，我们终于要真正开始操作我们的数据库了！\n\n先在我们的 xcdatamodeld 文件里面添加一个 Entity ，随便起个名字叫 User 好了，然后在右边 Attributes 那一栏里面添加一些属性。\n![attributes](/uploads/easy-core-data/attributes.png)￼\n\n\nAttributes 都是强类型的，所以如果你不手动给它们指定类型，编译器就会直接报错。能够写入数据库的类型还是挺丰富的，值得一提的是，数字和布尔值最终都会被转换成 `NSNumber` 来处理，而图片这一类比较大的文件就必须转换成 `NSData` 再写入了。\n\n接下来，让 Xcode 帮我们生成这个实体的子类：\n![create_subclasses](/uploads/easy-core-data/create_subclasses.png)￼\n\n\n选择一下 Model 和想要子类化的 Entity （有的项目会使用多个 Model，我们这里就只有一个）：\n![choose_mode](/uploads/easy-core-data/choose_model.png)￼\n![choose_entity](/uploads/easy-core-data/choose_entity.png)￼\n\n\n然后点 create ，你会发现项目文件夹中多两个文件 User.h/m。这两个文件由 Xcode 生成也由 Xcode 管理，所以如果我们改动了里面的内容，Xcode 可能就会跟我们发牢骚了。（如果确实需要添加某些功能，可以使用 category ）\n\n如今这个类已经全权代表了我们在模型里面创建的实体，它的 property 和我们添加的 attributes 是一一对应的关系，也就是可以直接从这些属性访问到实体的变量了。\n\n多说无益，赶紧来动动手！\n{% img [accept_challenge] /uploads/easy-core-data/accept_challenge.png 250 250 %}\n\n## Write the code, change the world!\n首先拉一个简陋的界面出来给我们的用户输入信息，下面放一个输出信息的地方，省的我们每次都跑到 Debug Area 里面看：\n{% img [main_v] /uploads/easy-core-data/main_vc.png Main VC %}\n\n\n把所有控件都 hook 起来，然后在“写进去”和\"读出来\"两个按钮的 IBAction 里写代码。\n首先把数据写进数据库：\n\n```objc\n\t- (IBAction)writeAction:(id)sender\n\t{\n\t    AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];\n\t    NSManagedObjectContext *context = appDelegate.managedObjectContext;\n\n\t    User *newUser = [NSEntityDescription insertNewObjectForEntityForName:@\"User\" inManagedObjectContext:context];\n\t    newUser.name = self.nameTextField.text;\n\t    newUser.age = @([self.ageTextField.text intValue]);\n\t    newUser.height = @([self.heightTextField.text intValue]);\n\t    newUser.weight = @([self.weightTextField.text intValue]);\n\n\t//    [context save:NULL];\n\t}\n```\n\nCore Data 用起来还是挺直观的吧？\n我们从 AppDelegate 里面拿到了老早就创建好了的 `managedObjectContext`，通过 `NSEntityDescription` 新建了一个准备插入到数据库中的 User；\n然后把用户输入的数据填充到 User 里面，保存一下。\n\n等等！ Core Data 是会自动保存的，所以最后一句注释掉也没有影响咯。\n\n接下来是读取数据：\n\n```objc\n\t- (IBAction)readAction:(id)sender\n\t{\n\t    AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];\n\t    NSManagedObjectContext *context = appDelegate.managedObjectContext;\n\n\t    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] initWithEntityName:@\"User\"];\n\t    NSError *error;\n\t    NSArray *results = [context executeFetchRequest:fetchRequest error:&error];\n\t    if ([results count]) {\n\t        self.consoleTextView.text = [results description];\n\t    } else {\n\t        self.consoleTextView.text = [error localizedDescription];\n\t    }\n\t}\n```\n\n认识一个新伙伴—— `NSFetchRequest`，数据库的读取基本都是靠这家伙了，你还可以对它加上各式各样的条件和约束，进行更精确的数据库查询。查询的结果会保存在一个 NSArray 里面，不管它，直接输出给我们看看。\n\n这就够了！让我们的程序跑起来吧！\n￼{% img [let_run] /uploads/easy-core-data/let_run.png  250 250 %}\n\n## 结果\n随便录入点数据，按下“写进去”，嗯，和预期的一样，什么反应也没有。\n然后按下\"读出来\"：\n<figure>\n{% img [result] /uploads/easy-core-data/result.png Result %}\n</figure>\n\n嗯？输出的结果看起来有点奇怪？\n那是因为我们直接把数组的 description 打印了出来。这个数组里面其实就是我们之前创建好的 User 对象，直接拿出来当Model用就可以了。\n","slug":"easy-core-data","published":1,"updated":"2016-05-09T02:39:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip56hb6t0008gr8ftthi4qq0","content":"<p>也不知道是我搜索的方法不对还是别的什么问题，网络上很少见 Core Data 的入门教程，所以这篇东西就这样定位了：比看官方文档轻松得多，却可以马上在自己的 App 里用上 Core Data。\n不求深入到可以拿出去显摆，但是起码要可以用上手，并且能分享一篇入门指南，就像现在这样:)</p>\n<a id=\"more\"></a>\n<h2>Launch our Xcode!</h2>\n<p>不管怎么样，先把咱熟悉的 Xcode 召唤起来，创建一个新项目。本项目的完整代码可以在<a href=\"https://github.com/davidleee/CoreDataTryout\" target=\"_blank\" rel=\"external\">这里</a>找到。对了，创建项目的时候记得把下面这个小勾给勾上，让 Xcode 帮我们创建模型文件。\n<img src=\"/uploads/easy-core-data/use_core_data.png\" alt=\"use_core_data\">￼</p>\n<p>然后就可以看到项目中出现一个后缀为 xcdatamodeld 的文件，这个文件相当于 Core Data 的 storyboard （不知道 <a href=\"https://developer.apple.com/videos/wwdc/2012/?id=407\" target=\"_blank\" rel=\"external\">storyboard</a>？）。选中它，你会看到这样几个东西：\n<img src=\"/uploads/easy-core-data/model_document.png\" alt=\"model_document\">￼</p>\n<p>在这篇文章里，我们就只关注 Entities 部分。</p>\n<h2>浅入浅出</h2>\n<p>想要详细了解 Core Data 里面的结构关系的话，可以去翻翻<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/cdProgrammingGuide.html#//apple_ref/doc/uid/TP40001075\" target=\"_blank\" rel=\"external\">官方文档</a>。但是一开始接触的时候，不外乎就是这么几个类：</p>\n<ul>\n<li>NSManagedObjectModel</li>\n</ul>\n<p>这玩意儿是什么呢？说白了，你可以认为它就是我们的 xcdatamodeld 。它包含了我们自己定义的实体( Entitiy )、实体内部的属性( Attribute )和实体之间的关系( Relationship )，就像是我们在设计数据库的时候画的E-R图。原则上，这个模型越是完善，你的 App 对 Core Data 的支持就越好。</p>\n<ul>\n<li>NSManagedObjectContext</li>\n</ul>\n<p>按照官方文档的<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdBasics.html#//apple_ref/doc/uid/TP40001650-SW3\" target=\"_blank\" rel=\"external\">说法</a>，<code>NSManagedObjectContext</code> 就像是一个智能的工作台。当你想从数据库中获取数据的时候，这些数据会被暂时复制一份到这个工作台上，然后你就可以对它们进行操作了。这样，除非你确实进行了一次保存，否则数据库里的真实数据是不会被改变的。</p>\n<p>而在实际使用中，我们最频繁接触的也是这个 <code>NSManagedObjectContext</code>。</p>\n<ul>\n<li>NSPersistentStoreCoordinator</li>\n</ul>\n<p>从名字大概可以猜到，这个类是不同数据库存储之间的协调者。</p>\n<p>在 App 里面创建出来的数据对象和实际保存着的数据之间，存在着一个持久栈( Persistence Stack )。这个栈的最顶层是 <code>NSManagedObjectContext</code>，而它的最底层则是一个个数据文件( Persistent Object Store )，在它们之间的就是 <code>NSPersistentStoreCoordinator</code>。我们因为 <code>NSManagedObjectContext</code>的存在，而不需要直接操作这些数据文件；而且 Persistent Store Coordinator 的存在，是基于外观模式的设计，这就使得 <code>NSManagedObjectContext</code> 不需要面对多个数据文件，只和 Coordinator 打交道就可以了。</p>\n<p>整个持久栈看起来就是这个样子：\n￼<img src=\"/uploads/easy-core-data/persistence_stack.png\" class=\"[persistence_stack]\" title=\"Persistence Stack\"></p>\n<p>好，铺垫了那么久，也该用实践来检验一下真理了。</p>\n<h2>准备工作</h2>\n<p>什么？上面讲了那么久的三个东西，Xcode 已经帮我们在 AppDelegate 里都准备好了？\n嗯，没错，很贴心嘛。\n￼<img src=\"/uploads/easy-core-data/r_u_kidding.png\" class=\"[r_u_kidding]\" width=\"250\" height=\"250\"></p>\n<p>不过我们还是来简单理一理这些代码里面的关系吧。</p>\n<p>可以发现，这几个对象的创建顺序是这样的 NSManagedObjectModel -&gt; NSPersistentStoreCoordinator -&gt; NSManagedObjectContext，跟持久栈的关系很一致。\n不过在此之前，我们还是需要拿到我们的 xcdatamodeld 才可以创建我们的模型：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURL</span> *modelURL = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"CoreDataTryout\"</span> withExtension:<span class=\"string\">@\"momd\"</span>];</span><br><span class=\"line\">_managedObjectModel = [[<span class=\"built_in\">NSManagedObjectModel</span> alloc] initWithContentsOfURL:modelURL];</span><br></pre></td></tr></table></figure>\n<p>然后用这个模型来创建 <code>NSPersistentStoreCoordinator</code>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_persistentStoreCoordinator = [[<span class=\"built_in\">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:[<span class=\"keyword\">self</span> managedObjectModel]];</span><br><span class=\"line\"> <span class=\"built_in\">NSURL</span> *storeURL = [[<span class=\"keyword\">self</span> applicationDocumentsDirectory] URLByAppendingPathComponent:<span class=\"string\">@\"CoreDataTryout.sqlite\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"> ...</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (![_persistentStoreCoordinator addPersistentStoreWithType:<span class=\"built_in\">NSSQLiteStoreType</span> configuration:<span class=\"literal\">nil</span> URL:storeURL options:<span class=\"literal\">nil</span> error:&amp;error]) &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>程序会在 App 的 document 目录中创建一个名为 CoreDataTryout.sqlite 的文件，<code>NSSQLiteStoreType</code> 是我们选择的数据库类型，我们还可以选择 XML（ iOS 上不支持）、Atomic 或者 In-Memory，如果这些类型你都不喜欢，你还可以创建<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdPersistentStores.html#//apple_ref/doc/uid/TP40002875-SW6\" target=\"_blank\" rel=\"external\">自定义存储类型</a>。</p>\n<p>最后，在 <code>managedObjectContext</code> 的 setter 里面，我们给它装上准备好的 <code>persistentStoreCoordinator</code> 就大功告成了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_managedObjectContext = [[<span class=\"built_in\">NSManagedObjectContext</span> alloc] init];</span><br><span class=\"line\">[_managedObjectContext setPersistentStoreCoordinator:coordinator];</span><br></pre></td></tr></table></figure>\n<p>注意到在 <code>application:didFinishLaunchingWithOptions:</code> 的最后还调用了一个 <code>saveContext</code> 方法。</p>\n<p>Core Data 里面的数据都是自动保存的，也就是说，你完全可以在代码里把实体的对象创建出来，乱改一通，然后留下一个帅气的背影，奔向下一段代码。\n<code>managedObjectContext</code> 在发现有数据被改动了之后，会在一个<em>合适的时机</em>保存这些更改。这个保存也许不是数据变化后马上进行的，但是也足够智能可以让我们免去时不时保存一下的烦恼。有些时候（比如你暂停了你运行中的程序） <code>managedObjectContext</code> 会来不及做这些工作，或者你想要确保当下的数据被写进了数据库里，那么这个 <code>saveContext</code> 就会派上用场了。</p>\n<h2>创建实体</h2>\n<p>一切准备就绪，我们终于要真正开始操作我们的数据库了！</p>\n<p>先在我们的 xcdatamodeld 文件里面添加一个 Entity ，随便起个名字叫 User 好了，然后在右边 Attributes 那一栏里面添加一些属性。\n<img src=\"/uploads/easy-core-data/attributes.png\" alt=\"attributes\">￼</p>\n<p>Attributes 都是强类型的，所以如果你不手动给它们指定类型，编译器就会直接报错。能够写入数据库的类型还是挺丰富的，值得一提的是，数字和布尔值最终都会被转换成 <code>NSNumber</code> 来处理，而图片这一类比较大的文件就必须转换成 <code>NSData</code> 再写入了。</p>\n<p>接下来，让 Xcode 帮我们生成这个实体的子类：\n<img src=\"/uploads/easy-core-data/create_subclasses.png\" alt=\"create_subclasses\">￼</p>\n<p>选择一下 Model 和想要子类化的 Entity （有的项目会使用多个 Model，我们这里就只有一个）：\n<img src=\"/uploads/easy-core-data/choose_model.png\" alt=\"choose_mode\">￼\n<img src=\"/uploads/easy-core-data/choose_entity.png\" alt=\"choose_entity\">￼</p>\n<p>然后点 create ，你会发现项目文件夹中多两个文件 User.h/m。这两个文件由 Xcode 生成也由 Xcode 管理，所以如果我们改动了里面的内容，Xcode 可能就会跟我们发牢骚了。（如果确实需要添加某些功能，可以使用 category ）</p>\n<p>如今这个类已经全权代表了我们在模型里面创建的实体，它的 property 和我们添加的 attributes 是一一对应的关系，也就是可以直接从这些属性访问到实体的变量了。</p>\n<p>多说无益，赶紧来动动手！</p>\n<img src=\"/uploads/easy-core-data/accept_challenge.png\" class=\"[accept_challenge]\" width=\"250\" height=\"250\">\n<h2>Write the code, change the world!</h2>\n<p>首先拉一个简陋的界面出来给我们的用户输入信息，下面放一个输出信息的地方，省的我们每次都跑到 Debug Area 里面看：</p>\n<img src=\"/uploads/easy-core-data/main_vc.png\" class=\"[main_v]\" title=\"Main VC\">\n<p>把所有控件都 hook 起来，然后在“写进去”和&quot;读出来&quot;两个按钮的 IBAction 里写代码。\n首先把数据写进数据库：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)writeAction:(<span class=\"keyword\">id</span>)sender</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AppDelegate *appDelegate = [[<span class=\"built_in\">UIApplication</span> sharedApplication] delegate];</span><br><span class=\"line\">    <span class=\"built_in\">NSManagedObjectContext</span> *context = appDelegate.managedObjectContext;</span><br><span class=\"line\"></span><br><span class=\"line\">    User *newUser = [<span class=\"built_in\">NSEntityDescription</span> insertNewObjectForEntityForName:<span class=\"string\">@\"User\"</span> inManagedObjectContext:context];</span><br><span class=\"line\">    newUser.name = <span class=\"keyword\">self</span>.nameTextField.text;</span><br><span class=\"line\">    newUser.age = @([<span class=\"keyword\">self</span>.ageTextField.text intValue]);</span><br><span class=\"line\">    newUser.height = @([<span class=\"keyword\">self</span>.heightTextField.text intValue]);</span><br><span class=\"line\">    newUser.weight = @([<span class=\"keyword\">self</span>.weightTextField.text intValue]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    [context save:NULL];</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Core Data 用起来还是挺直观的吧？\n我们从 AppDelegate 里面拿到了老早就创建好了的 <code>managedObjectContext</code>，通过 <code>NSEntityDescription</code> 新建了一个准备插入到数据库中的 User；\n然后把用户输入的数据填充到 User 里面，保存一下。</p>\n<p>等等！ Core Data 是会自动保存的，所以最后一句注释掉也没有影响咯。</p>\n<p>接下来是读取数据：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)readAction:(<span class=\"keyword\">id</span>)sender</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AppDelegate *appDelegate = [[<span class=\"built_in\">UIApplication</span> sharedApplication] delegate];</span><br><span class=\"line\">    <span class=\"built_in\">NSManagedObjectContext</span> *context = appDelegate.managedObjectContext;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSFetchRequest</span> *fetchRequest = [[<span class=\"built_in\">NSFetchRequest</span> alloc] initWithEntityName:<span class=\"string\">@\"User\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *results = [context executeFetchRequest:fetchRequest error:&amp;error];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([results count]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.consoleTextView.text = [results description];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.consoleTextView.text = [error localizedDescription];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>认识一个新伙伴—— <code>NSFetchRequest</code>，数据库的读取基本都是靠这家伙了，你还可以对它加上各式各样的条件和约束，进行更精确的数据库查询。查询的结果会保存在一个 NSArray 里面，不管它，直接输出给我们看看。</p>\n<p>这就够了！让我们的程序跑起来吧！\n￼<img src=\"/uploads/easy-core-data/let_run.png\" class=\"[let_run]\" width=\"250\" height=\"250\"></p>\n<h2>结果</h2>\n<p>随便录入点数据，按下“写进去”，嗯，和预期的一样，什么反应也没有。\n然后按下&quot;读出来&quot;：</p>\n<figure>\n<img src=\"/uploads/easy-core-data/result.png\" class=\"[result]\" title=\"Result\">\n</figure>\n<p>嗯？输出的结果看起来有点奇怪？\n那是因为我们直接把数组的 description 打印了出来。这个数组里面其实就是我们之前创建好的 User 对象，直接拿出来当Model用就可以了。</p>\n","excerpt":"<p>也不知道是我搜索的方法不对还是别的什么问题，网络上很少见 Core Data 的入门教程，所以这篇东西就这样定位了：比看官方文档轻松得多，却可以马上在自己的 App 里用上 Core Data。\n不求深入到可以拿出去显摆，但是起码要可以用上手，并且能分享一篇入门指南，就像现在这样:)</p>","more":"<h2>Launch our Xcode!</h2>\n<p>不管怎么样，先把咱熟悉的 Xcode 召唤起来，创建一个新项目。本项目的完整代码可以在<a href=\"https://github.com/davidleee/CoreDataTryout\">这里</a>找到。对了，创建项目的时候记得把下面这个小勾给勾上，让 Xcode 帮我们创建模型文件。\n<img src=\"/uploads/easy-core-data/use_core_data.png\" alt=\"use_core_data\">￼</p>\n<p>然后就可以看到项目中出现一个后缀为 xcdatamodeld 的文件，这个文件相当于 Core Data 的 storyboard （不知道 <a href=\"https://developer.apple.com/videos/wwdc/2012/?id=407\">storyboard</a>？）。选中它，你会看到这样几个东西：\n<img src=\"/uploads/easy-core-data/model_document.png\" alt=\"model_document\">￼</p>\n<p>在这篇文章里，我们就只关注 Entities 部分。</p>\n<h2>浅入浅出</h2>\n<p>想要详细了解 Core Data 里面的结构关系的话，可以去翻翻<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/cdProgrammingGuide.html#//apple_ref/doc/uid/TP40001075\">官方文档</a>。但是一开始接触的时候，不外乎就是这么几个类：</p>\n<ul>\n<li>NSManagedObjectModel</li>\n</ul>\n<p>这玩意儿是什么呢？说白了，你可以认为它就是我们的 xcdatamodeld 。它包含了我们自己定义的实体( Entitiy )、实体内部的属性( Attribute )和实体之间的关系( Relationship )，就像是我们在设计数据库的时候画的E-R图。原则上，这个模型越是完善，你的 App 对 Core Data 的支持就越好。</p>\n<ul>\n<li>NSManagedObjectContext</li>\n</ul>\n<p>按照官方文档的<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdBasics.html#//apple_ref/doc/uid/TP40001650-SW3\">说法</a>，<code>NSManagedObjectContext</code> 就像是一个智能的工作台。当你想从数据库中获取数据的时候，这些数据会被暂时复制一份到这个工作台上，然后你就可以对它们进行操作了。这样，除非你确实进行了一次保存，否则数据库里的真实数据是不会被改变的。</p>\n<p>而在实际使用中，我们最频繁接触的也是这个 <code>NSManagedObjectContext</code>。</p>\n<ul>\n<li>NSPersistentStoreCoordinator</li>\n</ul>\n<p>从名字大概可以猜到，这个类是不同数据库存储之间的协调者。</p>\n<p>在 App 里面创建出来的数据对象和实际保存着的数据之间，存在着一个持久栈( Persistence Stack )。这个栈的最顶层是 <code>NSManagedObjectContext</code>，而它的最底层则是一个个数据文件( Persistent Object Store )，在它们之间的就是 <code>NSPersistentStoreCoordinator</code>。我们因为 <code>NSManagedObjectContext</code>的存在，而不需要直接操作这些数据文件；而且 Persistent Store Coordinator 的存在，是基于外观模式的设计，这就使得 <code>NSManagedObjectContext</code> 不需要面对多个数据文件，只和 Coordinator 打交道就可以了。</p>\n<p>整个持久栈看起来就是这个样子：\n￼<img src=\"/uploads/easy-core-data/persistence_stack.png\" class=\"[persistence_stack]\" title=\"Persistence Stack\"></p>\n<p>好，铺垫了那么久，也该用实践来检验一下真理了。</p>\n<h2>准备工作</h2>\n<p>什么？上面讲了那么久的三个东西，Xcode 已经帮我们在 AppDelegate 里都准备好了？\n嗯，没错，很贴心嘛。\n￼<img src=\"/uploads/easy-core-data/r_u_kidding.png\" class=\"[r_u_kidding]\" width=\"250\" height=\"250\"></p>\n<p>不过我们还是来简单理一理这些代码里面的关系吧。</p>\n<p>可以发现，这几个对象的创建顺序是这样的 NSManagedObjectModel -&gt; NSPersistentStoreCoordinator -&gt; NSManagedObjectContext，跟持久栈的关系很一致。\n不过在此之前，我们还是需要拿到我们的 xcdatamodeld 才可以创建我们的模型：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURL</span> *modelURL = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"CoreDataTryout\"</span> withExtension:<span class=\"string\">@\"momd\"</span>];</span><br><span class=\"line\">_managedObjectModel = [[<span class=\"built_in\">NSManagedObjectModel</span> alloc] initWithContentsOfURL:modelURL];</span><br></pre></td></tr></table></figure>\n<p>然后用这个模型来创建 <code>NSPersistentStoreCoordinator</code>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_persistentStoreCoordinator = [[<span class=\"built_in\">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:[<span class=\"keyword\">self</span> managedObjectModel]];</span><br><span class=\"line\"> <span class=\"built_in\">NSURL</span> *storeURL = [[<span class=\"keyword\">self</span> applicationDocumentsDirectory] URLByAppendingPathComponent:<span class=\"string\">@\"CoreDataTryout.sqlite\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"> ...</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (![_persistentStoreCoordinator addPersistentStoreWithType:<span class=\"built_in\">NSSQLiteStoreType</span> configuration:<span class=\"literal\">nil</span> URL:storeURL options:<span class=\"literal\">nil</span> error:&amp;error]) &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>程序会在 App 的 document 目录中创建一个名为 CoreDataTryout.sqlite 的文件，<code>NSSQLiteStoreType</code> 是我们选择的数据库类型，我们还可以选择 XML（ iOS 上不支持）、Atomic 或者 In-Memory，如果这些类型你都不喜欢，你还可以创建<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdPersistentStores.html#//apple_ref/doc/uid/TP40002875-SW6\">自定义存储类型</a>。</p>\n<p>最后，在 <code>managedObjectContext</code> 的 setter 里面，我们给它装上准备好的 <code>persistentStoreCoordinator</code> 就大功告成了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_managedObjectContext = [[<span class=\"built_in\">NSManagedObjectContext</span> alloc] init];</span><br><span class=\"line\">[_managedObjectContext setPersistentStoreCoordinator:coordinator];</span><br></pre></td></tr></table></figure>\n<p>注意到在 <code>application:didFinishLaunchingWithOptions:</code> 的最后还调用了一个 <code>saveContext</code> 方法。</p>\n<p>Core Data 里面的数据都是自动保存的，也就是说，你完全可以在代码里把实体的对象创建出来，乱改一通，然后留下一个帅气的背影，奔向下一段代码。\n<code>managedObjectContext</code> 在发现有数据被改动了之后，会在一个<em>合适的时机</em>保存这些更改。这个保存也许不是数据变化后马上进行的，但是也足够智能可以让我们免去时不时保存一下的烦恼。有些时候（比如你暂停了你运行中的程序） <code>managedObjectContext</code> 会来不及做这些工作，或者你想要确保当下的数据被写进了数据库里，那么这个 <code>saveContext</code> 就会派上用场了。</p>\n<h2>创建实体</h2>\n<p>一切准备就绪，我们终于要真正开始操作我们的数据库了！</p>\n<p>先在我们的 xcdatamodeld 文件里面添加一个 Entity ，随便起个名字叫 User 好了，然后在右边 Attributes 那一栏里面添加一些属性。\n<img src=\"/uploads/easy-core-data/attributes.png\" alt=\"attributes\">￼</p>\n<p>Attributes 都是强类型的，所以如果你不手动给它们指定类型，编译器就会直接报错。能够写入数据库的类型还是挺丰富的，值得一提的是，数字和布尔值最终都会被转换成 <code>NSNumber</code> 来处理，而图片这一类比较大的文件就必须转换成 <code>NSData</code> 再写入了。</p>\n<p>接下来，让 Xcode 帮我们生成这个实体的子类：\n<img src=\"/uploads/easy-core-data/create_subclasses.png\" alt=\"create_subclasses\">￼</p>\n<p>选择一下 Model 和想要子类化的 Entity （有的项目会使用多个 Model，我们这里就只有一个）：\n<img src=\"/uploads/easy-core-data/choose_model.png\" alt=\"choose_mode\">￼\n<img src=\"/uploads/easy-core-data/choose_entity.png\" alt=\"choose_entity\">￼</p>\n<p>然后点 create ，你会发现项目文件夹中多两个文件 User.h/m。这两个文件由 Xcode 生成也由 Xcode 管理，所以如果我们改动了里面的内容，Xcode 可能就会跟我们发牢骚了。（如果确实需要添加某些功能，可以使用 category ）</p>\n<p>如今这个类已经全权代表了我们在模型里面创建的实体，它的 property 和我们添加的 attributes 是一一对应的关系，也就是可以直接从这些属性访问到实体的变量了。</p>\n<p>多说无益，赶紧来动动手！</p>\n<img src=\"/uploads/easy-core-data/accept_challenge.png\" class=\"[accept_challenge]\" width=\"250\" height=\"250\">\n<h2>Write the code, change the world!</h2>\n<p>首先拉一个简陋的界面出来给我们的用户输入信息，下面放一个输出信息的地方，省的我们每次都跑到 Debug Area 里面看：</p>\n<img src=\"/uploads/easy-core-data/main_vc.png\" class=\"[main_v]\" title=\"Main VC\">\n<p>把所有控件都 hook 起来，然后在“写进去”和&quot;读出来&quot;两个按钮的 IBAction 里写代码。\n首先把数据写进数据库：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)writeAction:(<span class=\"keyword\">id</span>)sender</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AppDelegate *appDelegate = [[<span class=\"built_in\">UIApplication</span> sharedApplication] delegate];</span><br><span class=\"line\">    <span class=\"built_in\">NSManagedObjectContext</span> *context = appDelegate.managedObjectContext;</span><br><span class=\"line\"></span><br><span class=\"line\">    User *newUser = [<span class=\"built_in\">NSEntityDescription</span> insertNewObjectForEntityForName:<span class=\"string\">@\"User\"</span> inManagedObjectContext:context];</span><br><span class=\"line\">    newUser.name = <span class=\"keyword\">self</span>.nameTextField.text;</span><br><span class=\"line\">    newUser.age = @([<span class=\"keyword\">self</span>.ageTextField.text intValue]);</span><br><span class=\"line\">    newUser.height = @([<span class=\"keyword\">self</span>.heightTextField.text intValue]);</span><br><span class=\"line\">    newUser.weight = @([<span class=\"keyword\">self</span>.weightTextField.text intValue]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    [context save:NULL];</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Core Data 用起来还是挺直观的吧？\n我们从 AppDelegate 里面拿到了老早就创建好了的 <code>managedObjectContext</code>，通过 <code>NSEntityDescription</code> 新建了一个准备插入到数据库中的 User；\n然后把用户输入的数据填充到 User 里面，保存一下。</p>\n<p>等等！ Core Data 是会自动保存的，所以最后一句注释掉也没有影响咯。</p>\n<p>接下来是读取数据：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)readAction:(<span class=\"keyword\">id</span>)sender</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AppDelegate *appDelegate = [[<span class=\"built_in\">UIApplication</span> sharedApplication] delegate];</span><br><span class=\"line\">    <span class=\"built_in\">NSManagedObjectContext</span> *context = appDelegate.managedObjectContext;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSFetchRequest</span> *fetchRequest = [[<span class=\"built_in\">NSFetchRequest</span> alloc] initWithEntityName:<span class=\"string\">@\"User\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *results = [context executeFetchRequest:fetchRequest error:&amp;error];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([results count]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.consoleTextView.text = [results description];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.consoleTextView.text = [error localizedDescription];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>认识一个新伙伴—— <code>NSFetchRequest</code>，数据库的读取基本都是靠这家伙了，你还可以对它加上各式各样的条件和约束，进行更精确的数据库查询。查询的结果会保存在一个 NSArray 里面，不管它，直接输出给我们看看。</p>\n<p>这就够了！让我们的程序跑起来吧！\n￼<img src=\"/uploads/easy-core-data/let_run.png\" class=\"[let_run]\" width=\"250\" height=\"250\"></p>\n<h2>结果</h2>\n<p>随便录入点数据，按下“写进去”，嗯，和预期的一样，什么反应也没有。\n然后按下&quot;读出来&quot;：</p>\n<figure>\n<img src=\"/uploads/easy-core-data/result.png\" class=\"[result]\" title=\"Result\">\n</figure>\n<p>嗯？输出的结果看起来有点奇怪？\n那是因为我们直接把数组的 description 打印了出来。这个数组里面其实就是我们之前创建好的 User 对象，直接拿出来当Model用就可以了。</p>"},{"title":"老生常谈的自适应高度UITableViewCell","date":"2016-04-29T07:44:39.000Z","_content":"\nUITableViewCell 自适应内容高度已经是一个老生常谈的问题了，网络上也随处可以找到相关的资料。从 iOS 8 开始，强大的 AutoLayout 甚至已经可以直接接管 Cell 高度的计算，于是这一话题也就慢慢淡出了人们的视野，包括我...\n最近整理笔记的时候发现了这篇文章，想了想还是把它弄到新博客上来了。这篇文章是做毕业设计的时候（2014）总结下来的，当时因为要兼容到 iOS 7 ，所以用的都是比较原始的方法，不过在那个时候用起来还是比较顺手的（只是对比起 iOS 8 的用法，那真叫一个酸爽）。随着 iOS 后面的版本号越来越大，兼容 iOS 7 的应用应该也不多了，现在把它搬到这上面来，主要是为了记录以往走过的路，这些知识或许再也用不上，但积累它们的过程还是非常值得保留的。~~另一个原因是为了扩充新博客的文章数目。~~（喂！）\n\n<!-- more -->\n\n## 告诉我需求！\n文中的界面制作使用的是 Storyboard，也会略微对比使用 xib 和纯代码的情况。\n\n首先假设这么一种情况，我们的 UITableViewCell 里面只使用到一种布局：\n![cell-UI](/uploads/using-autolayout-in-uitableviewcells/cell-ui.png)\n其中， State 只显示一行； Name 最多只能显示3行，字体大小不改变； Additional 可以显示任意多行，字体大小不改变。\n如果 cell 的布局变化比较大，比如说文字下面可能还有图片，4张图片和9张图片的布局要不同，那么还是建议把相去甚远的几种布局分别设计成几个不同的 cell，用 Cell Identifier 来区分彼此，然后再分别对每一个 cell 进行自适应内容高度的处理。\n\n## 最喜欢IB了 - 约束设置\n既然使用的是 Storyboard，那么一切的约束当然都是在 Storyboard 里面手动进行。\n想要让 cell 根据内容自动调整高度，一个极其重要也似乎是唯一的原则是：约束自上而下贯通整个 contentView。\n\n还是拿上面的截图做例子：\n1. State 必须要有一个 Top Space to: Superview，这个 Superview 应该是 cell 的 contentView 而不是 cell 本身。\n2. Name 要有一个 Top Space to: State，而这个 constant 是多少就可以随意了，它的作用主要是把二者的垂直空间连起来，怎么连、连多长都是看心情的事。\n3. Additional 除了要有一个 Top Space To: Name 之外，还需要有一个 Bottom Space To: Superview（这个也是 contentView）。\n\n其实，如果将旁边的数字 1 连到了 contentView 的 top 上，再把 State 跟数字 1 的 center Y 等同一下，也可以达到同样的效果。只是如果使用上面的构建方法，数字 1 就可以自己一边玩儿去了，因为三个 UILabel 已经完成了“确定 cell 所需高度”的关键任务。\n\n## Write the code, change the world!\n下面将分别针对 UITableView 中需要进行修改的不同几处分开来进行说明。\n\n### 主角 - CustomCell.m\n相对来说最忙的应该是 CustomCell 这个自定义类了，所以放到最前面来说。\n在这个地方，需要关注的其实也只有两件事：\n\n1. 为 cell 填充内容。\n2. layoutSubviews。\n\n#### 填充内容\n其实就是属性的设置而已，但是需要注意的是，对于 UILabel 来说，我们想要看到的是，当显示的内容很多的时候，它可以有一个确定的宽度，然后多出来的内容自动往下接着排列下去。比较好的办法是，继承 UILabel，然后在子类中自己实现。这种做法也不麻烦，放到后面再说，现在我们这里就只是简单的设置几个 text 。\n> 代码呢？\n\n这么简单的赋值代码，我不贴！我不贴！\n\n#### layoutSubviews\n如果没有用继承 UILabel 的那套方案，那么这一步就是必须的，否则就是多余的。这里还是用到了继承的方案。\n我们需要重写 cell 的 layoutSubviews 方法，并让它为我们的 UILabel 设定一些规矩：\n![layoutSubviews-code](/uploads/using-autolayout-in-uitableviewcells/layoutSubviews-code.png)\n代码非常简单，因为当运行到这里的时候，AutoLayout 已经帮我们处理好了一大堆布局的问题，我们只需要告诉 UILabel ，我想要你显示多宽就可以了。\n\n### 主角诞生的地方 - cellForRowAtIndexPath\n除了常规的获取和配置 cell 之外，我们最好在最后面补上两句简短的代码：\n![cellForRowAtIndexPath-code](/uploads/using-autolayout-in-uitableviewcells/cellForRowAtIndexPath-code.png)\n这两句的作用是告诉我们能者多劳的 cell，如果你发现自己的约束改变了，那么就马上更新一下自己。不写这两句问题也不大，只是为了防止某些特殊情况下 cell 的显示异常。\n\n### 到底要我长多高你才满意？！ - heightForRowAtIndexPath\n最关键的地方来了，告诉 tableView 每个 cell 到底该是多高。这里有三个关键步骤：\n\n1. 创建一个offscreen cell。\n2. 模拟真实的cell填充数据。\n3. 计算出这个offscreen cell的高度。\n\n实际上，我们要做的就是制作一个和当前位置需要显示的 cell 一模一样但却不会显示出来的 cell （好拗口），然后告诉 delegate 这个 cell 的高度即可。\n\n#### Offscreen Cell\n实验发现，“创建一个 offscreen cell ”是非常讲究的：\n\n* 如果使用 `[tableView dequeueReusableCellWithIdentifier:CellIdentifier atIndexPath:indexPath]` 来获得一个 cell ，会造成内存的泄漏，因为上面这个方法在调用之前会先调用 heightForRowAtIndexPath 这个方法本身，有点像循环引用的概念。\n* 直接用 `[[CustomCell alloc] init]` 来创建一个 cell 呢？如果使用的是 xib 或者纯代码的方式来创建布局的，那么当然没问题，不过千万不要忘了，在 VC 的某个地方调用一个 tableView 的 `registerClass:forCellReuseIdentifier:` 方法，把这个 CustomCell 给注册一下，否则会拿不到 cell 对应的属性。\n* 对于 Storyboard 来说，因为 CustomCell 是直接放在 tableView 里面的，IB 已经帮你完成了这一切，所以不需要 registerClass 。如果你执意要注册一下的话，不仅没有任何好处，反而会破坏了 IB 的和谐，导致 `tableView:cellForRowAtIndexPath:` 里面的 dequeue 方法无法返回一个正确的 cell。\n\n综上所述，用 Storyboard 就没有办法完成“创建一个 offscreen cell ”这一步了么？非也。\nTableView 还有一个方法叫 `[dequeueReusableCellWithIdentifier:]` ，注意到它没有了 indexPath 这个参数，所以它不会去调用 `tableView:heightForRowAtIndexPath:` ，这给我们提供了一线希望。于是，完整的代码是这样的：\n![offscreen-cell-code](/uploads/using-autolayout-in-uitableviewcells/offscreen-cell-code.png)\n\n这里用到了 static 和 dispatch_once 来使得这个 offscreen cell 只需要被创建一次，然后就可以循环利用了，环保？\n\n#### 填充数据\n这里又是常规的填充数据，再啰嗦一次：如果使用了子类化 UILabel，那么这一步做的事会比看起来强大得多。不过，目前为止，这里看起来也只是填充一下数据而已。\n\n#### 计算高度\n这里我们要用到 cell.contentView 里一个很强大的方法：`[systemLayoutSizeFittingSize:]`，后面跟的参数有两个可选项： `UILayoutFittingCompressedSize` 和 `UILayoutFittingExpandSize` ，前者会得到满足所有约束的最小 size ，后者得到的是最大 size 。\n\n这个方法看似方便，但也是因为我们前面做了许许多多的铺路：我们设置了贯通上下的约束，让 cell 能知道自己的内容总共有多高；我们设置了 UILabel 的 preferredMaxLayoutWidth ，让它们知道内容太多的时候要往下排列，等等等等。\n\n在调用这个方法之前，为了保险起见，还是要让 cell 自己适当排列一下自己的 subviews ，完整代码如下：\n![return-height-code](/uploads/using-autolayout-in-uitableviewcells/return-height-code.png)\n最后的`+1`只是为了让 cell 之间有 1pt 的空间容纳 separator。\n\n## 写在最后\n到这里，一个可以自适应内容高度的 cell 就已经做好了。虽然整篇文章看起来挺长，但是实际写起来代码量也并不大。\n\n其实如果还是觉得麻烦的话，让应用直接支持 iOS 8 以上不就好了:)\n","source":"_posts/using-autolayout-in-uitableviewcells.md","raw":"---\ntitle: 老生常谈的自适应高度UITableViewCell\ndate: 2016-04-29 15:44:39\ntags:\n- iOS\n- AutoLayout\n- UITableViewCell\n---\n\nUITableViewCell 自适应内容高度已经是一个老生常谈的问题了，网络上也随处可以找到相关的资料。从 iOS 8 开始，强大的 AutoLayout 甚至已经可以直接接管 Cell 高度的计算，于是这一话题也就慢慢淡出了人们的视野，包括我...\n最近整理笔记的时候发现了这篇文章，想了想还是把它弄到新博客上来了。这篇文章是做毕业设计的时候（2014）总结下来的，当时因为要兼容到 iOS 7 ，所以用的都是比较原始的方法，不过在那个时候用起来还是比较顺手的（只是对比起 iOS 8 的用法，那真叫一个酸爽）。随着 iOS 后面的版本号越来越大，兼容 iOS 7 的应用应该也不多了，现在把它搬到这上面来，主要是为了记录以往走过的路，这些知识或许再也用不上，但积累它们的过程还是非常值得保留的。~~另一个原因是为了扩充新博客的文章数目。~~（喂！）\n\n<!-- more -->\n\n## 告诉我需求！\n文中的界面制作使用的是 Storyboard，也会略微对比使用 xib 和纯代码的情况。\n\n首先假设这么一种情况，我们的 UITableViewCell 里面只使用到一种布局：\n![cell-UI](/uploads/using-autolayout-in-uitableviewcells/cell-ui.png)\n其中， State 只显示一行； Name 最多只能显示3行，字体大小不改变； Additional 可以显示任意多行，字体大小不改变。\n如果 cell 的布局变化比较大，比如说文字下面可能还有图片，4张图片和9张图片的布局要不同，那么还是建议把相去甚远的几种布局分别设计成几个不同的 cell，用 Cell Identifier 来区分彼此，然后再分别对每一个 cell 进行自适应内容高度的处理。\n\n## 最喜欢IB了 - 约束设置\n既然使用的是 Storyboard，那么一切的约束当然都是在 Storyboard 里面手动进行。\n想要让 cell 根据内容自动调整高度，一个极其重要也似乎是唯一的原则是：约束自上而下贯通整个 contentView。\n\n还是拿上面的截图做例子：\n1. State 必须要有一个 Top Space to: Superview，这个 Superview 应该是 cell 的 contentView 而不是 cell 本身。\n2. Name 要有一个 Top Space to: State，而这个 constant 是多少就可以随意了，它的作用主要是把二者的垂直空间连起来，怎么连、连多长都是看心情的事。\n3. Additional 除了要有一个 Top Space To: Name 之外，还需要有一个 Bottom Space To: Superview（这个也是 contentView）。\n\n其实，如果将旁边的数字 1 连到了 contentView 的 top 上，再把 State 跟数字 1 的 center Y 等同一下，也可以达到同样的效果。只是如果使用上面的构建方法，数字 1 就可以自己一边玩儿去了，因为三个 UILabel 已经完成了“确定 cell 所需高度”的关键任务。\n\n## Write the code, change the world!\n下面将分别针对 UITableView 中需要进行修改的不同几处分开来进行说明。\n\n### 主角 - CustomCell.m\n相对来说最忙的应该是 CustomCell 这个自定义类了，所以放到最前面来说。\n在这个地方，需要关注的其实也只有两件事：\n\n1. 为 cell 填充内容。\n2. layoutSubviews。\n\n#### 填充内容\n其实就是属性的设置而已，但是需要注意的是，对于 UILabel 来说，我们想要看到的是，当显示的内容很多的时候，它可以有一个确定的宽度，然后多出来的内容自动往下接着排列下去。比较好的办法是，继承 UILabel，然后在子类中自己实现。这种做法也不麻烦，放到后面再说，现在我们这里就只是简单的设置几个 text 。\n> 代码呢？\n\n这么简单的赋值代码，我不贴！我不贴！\n\n#### layoutSubviews\n如果没有用继承 UILabel 的那套方案，那么这一步就是必须的，否则就是多余的。这里还是用到了继承的方案。\n我们需要重写 cell 的 layoutSubviews 方法，并让它为我们的 UILabel 设定一些规矩：\n![layoutSubviews-code](/uploads/using-autolayout-in-uitableviewcells/layoutSubviews-code.png)\n代码非常简单，因为当运行到这里的时候，AutoLayout 已经帮我们处理好了一大堆布局的问题，我们只需要告诉 UILabel ，我想要你显示多宽就可以了。\n\n### 主角诞生的地方 - cellForRowAtIndexPath\n除了常规的获取和配置 cell 之外，我们最好在最后面补上两句简短的代码：\n![cellForRowAtIndexPath-code](/uploads/using-autolayout-in-uitableviewcells/cellForRowAtIndexPath-code.png)\n这两句的作用是告诉我们能者多劳的 cell，如果你发现自己的约束改变了，那么就马上更新一下自己。不写这两句问题也不大，只是为了防止某些特殊情况下 cell 的显示异常。\n\n### 到底要我长多高你才满意？！ - heightForRowAtIndexPath\n最关键的地方来了，告诉 tableView 每个 cell 到底该是多高。这里有三个关键步骤：\n\n1. 创建一个offscreen cell。\n2. 模拟真实的cell填充数据。\n3. 计算出这个offscreen cell的高度。\n\n实际上，我们要做的就是制作一个和当前位置需要显示的 cell 一模一样但却不会显示出来的 cell （好拗口），然后告诉 delegate 这个 cell 的高度即可。\n\n#### Offscreen Cell\n实验发现，“创建一个 offscreen cell ”是非常讲究的：\n\n* 如果使用 `[tableView dequeueReusableCellWithIdentifier:CellIdentifier atIndexPath:indexPath]` 来获得一个 cell ，会造成内存的泄漏，因为上面这个方法在调用之前会先调用 heightForRowAtIndexPath 这个方法本身，有点像循环引用的概念。\n* 直接用 `[[CustomCell alloc] init]` 来创建一个 cell 呢？如果使用的是 xib 或者纯代码的方式来创建布局的，那么当然没问题，不过千万不要忘了，在 VC 的某个地方调用一个 tableView 的 `registerClass:forCellReuseIdentifier:` 方法，把这个 CustomCell 给注册一下，否则会拿不到 cell 对应的属性。\n* 对于 Storyboard 来说，因为 CustomCell 是直接放在 tableView 里面的，IB 已经帮你完成了这一切，所以不需要 registerClass 。如果你执意要注册一下的话，不仅没有任何好处，反而会破坏了 IB 的和谐，导致 `tableView:cellForRowAtIndexPath:` 里面的 dequeue 方法无法返回一个正确的 cell。\n\n综上所述，用 Storyboard 就没有办法完成“创建一个 offscreen cell ”这一步了么？非也。\nTableView 还有一个方法叫 `[dequeueReusableCellWithIdentifier:]` ，注意到它没有了 indexPath 这个参数，所以它不会去调用 `tableView:heightForRowAtIndexPath:` ，这给我们提供了一线希望。于是，完整的代码是这样的：\n![offscreen-cell-code](/uploads/using-autolayout-in-uitableviewcells/offscreen-cell-code.png)\n\n这里用到了 static 和 dispatch_once 来使得这个 offscreen cell 只需要被创建一次，然后就可以循环利用了，环保？\n\n#### 填充数据\n这里又是常规的填充数据，再啰嗦一次：如果使用了子类化 UILabel，那么这一步做的事会比看起来强大得多。不过，目前为止，这里看起来也只是填充一下数据而已。\n\n#### 计算高度\n这里我们要用到 cell.contentView 里一个很强大的方法：`[systemLayoutSizeFittingSize:]`，后面跟的参数有两个可选项： `UILayoutFittingCompressedSize` 和 `UILayoutFittingExpandSize` ，前者会得到满足所有约束的最小 size ，后者得到的是最大 size 。\n\n这个方法看似方便，但也是因为我们前面做了许许多多的铺路：我们设置了贯通上下的约束，让 cell 能知道自己的内容总共有多高；我们设置了 UILabel 的 preferredMaxLayoutWidth ，让它们知道内容太多的时候要往下排列，等等等等。\n\n在调用这个方法之前，为了保险起见，还是要让 cell 自己适当排列一下自己的 subviews ，完整代码如下：\n![return-height-code](/uploads/using-autolayout-in-uitableviewcells/return-height-code.png)\n最后的`+1`只是为了让 cell 之间有 1pt 的空间容纳 separator。\n\n## 写在最后\n到这里，一个可以自适应内容高度的 cell 就已经做好了。虽然整篇文章看起来挺长，但是实际写起来代码量也并不大。\n\n其实如果还是觉得麻烦的话，让应用直接支持 iOS 8 以上不就好了:)\n","slug":"using-autolayout-in-uitableviewcells","published":1,"updated":"2016-04-29T08:54:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip56hb6v0009gr8fay07g30u","content":"<p>UITableViewCell 自适应内容高度已经是一个老生常谈的问题了，网络上也随处可以找到相关的资料。从 iOS 8 开始，强大的 AutoLayout 甚至已经可以直接接管 Cell 高度的计算，于是这一话题也就慢慢淡出了人们的视野，包括我...\n最近整理笔记的时候发现了这篇文章，想了想还是把它弄到新博客上来了。这篇文章是做毕业设计的时候（2014）总结下来的，当时因为要兼容到 iOS 7 ，所以用的都是比较原始的方法，不过在那个时候用起来还是比较顺手的（只是对比起 iOS 8 的用法，那真叫一个酸爽）。随着 iOS 后面的版本号越来越大，兼容 iOS 7 的应用应该也不多了，现在把它搬到这上面来，主要是为了记录以往走过的路，这些知识或许再也用不上，但积累它们的过程还是非常值得保留的。<s>另一个原因是为了扩充新博客的文章数目。</s>（喂！）</p>\n<a id=\"more\"></a>\n<h2>告诉我需求！</h2>\n<p>文中的界面制作使用的是 Storyboard，也会略微对比使用 xib 和纯代码的情况。</p>\n<p>首先假设这么一种情况，我们的 UITableViewCell 里面只使用到一种布局：\n<img src=\"/uploads/using-autolayout-in-uitableviewcells/cell-ui.png\" alt=\"cell-UI\">\n其中， State 只显示一行； Name 最多只能显示3行，字体大小不改变； Additional 可以显示任意多行，字体大小不改变。\n如果 cell 的布局变化比较大，比如说文字下面可能还有图片，4张图片和9张图片的布局要不同，那么还是建议把相去甚远的几种布局分别设计成几个不同的 cell，用 Cell Identifier 来区分彼此，然后再分别对每一个 cell 进行自适应内容高度的处理。</p>\n<h2>最喜欢IB了 - 约束设置</h2>\n<p>既然使用的是 Storyboard，那么一切的约束当然都是在 Storyboard 里面手动进行。\n想要让 cell 根据内容自动调整高度，一个极其重要也似乎是唯一的原则是：约束自上而下贯通整个 contentView。</p>\n<p>还是拿上面的截图做例子：</p>\n<ol>\n<li>State 必须要有一个 Top Space to: Superview，这个 Superview 应该是 cell 的 contentView 而不是 cell 本身。</li>\n<li>Name 要有一个 Top Space to: State，而这个 constant 是多少就可以随意了，它的作用主要是把二者的垂直空间连起来，怎么连、连多长都是看心情的事。</li>\n<li>Additional 除了要有一个 Top Space To: Name 之外，还需要有一个 Bottom Space To: Superview（这个也是 contentView）。</li>\n</ol>\n<p>其实，如果将旁边的数字 1 连到了 contentView 的 top 上，再把 State 跟数字 1 的 center Y 等同一下，也可以达到同样的效果。只是如果使用上面的构建方法，数字 1 就可以自己一边玩儿去了，因为三个 UILabel 已经完成了“确定 cell 所需高度”的关键任务。</p>\n<h2>Write the code, change the world!</h2>\n<p>下面将分别针对 UITableView 中需要进行修改的不同几处分开来进行说明。</p>\n<h3>主角 - CustomCell.m</h3>\n<p>相对来说最忙的应该是 CustomCell 这个自定义类了，所以放到最前面来说。\n在这个地方，需要关注的其实也只有两件事：</p>\n<ol>\n<li>为 cell 填充内容。</li>\n<li>layoutSubviews。</li>\n</ol>\n<h4>填充内容</h4>\n<p>其实就是属性的设置而已，但是需要注意的是，对于 UILabel 来说，我们想要看到的是，当显示的内容很多的时候，它可以有一个确定的宽度，然后多出来的内容自动往下接着排列下去。比较好的办法是，继承 UILabel，然后在子类中自己实现。这种做法也不麻烦，放到后面再说，现在我们这里就只是简单的设置几个 text 。</p>\n<blockquote>\n<p>代码呢？</p>\n</blockquote>\n<p>这么简单的赋值代码，我不贴！我不贴！</p>\n<h4>layoutSubviews</h4>\n<p>如果没有用继承 UILabel 的那套方案，那么这一步就是必须的，否则就是多余的。这里还是用到了继承的方案。\n我们需要重写 cell 的 layoutSubviews 方法，并让它为我们的 UILabel 设定一些规矩：\n<img src=\"/uploads/using-autolayout-in-uitableviewcells/layoutSubviews-code.png\" alt=\"layoutSubviews-code\">\n代码非常简单，因为当运行到这里的时候，AutoLayout 已经帮我们处理好了一大堆布局的问题，我们只需要告诉 UILabel ，我想要你显示多宽就可以了。</p>\n<h3>主角诞生的地方 - cellForRowAtIndexPath</h3>\n<p>除了常规的获取和配置 cell 之外，我们最好在最后面补上两句简短的代码：\n<img src=\"/uploads/using-autolayout-in-uitableviewcells/cellForRowAtIndexPath-code.png\" alt=\"cellForRowAtIndexPath-code\">\n这两句的作用是告诉我们能者多劳的 cell，如果你发现自己的约束改变了，那么就马上更新一下自己。不写这两句问题也不大，只是为了防止某些特殊情况下 cell 的显示异常。</p>\n<h3>到底要我长多高你才满意？！ - heightForRowAtIndexPath</h3>\n<p>最关键的地方来了，告诉 tableView 每个 cell 到底该是多高。这里有三个关键步骤：</p>\n<ol>\n<li>创建一个offscreen cell。</li>\n<li>模拟真实的cell填充数据。</li>\n<li>计算出这个offscreen cell的高度。</li>\n</ol>\n<p>实际上，我们要做的就是制作一个和当前位置需要显示的 cell 一模一样但却不会显示出来的 cell （好拗口），然后告诉 delegate 这个 cell 的高度即可。</p>\n<h4>Offscreen Cell</h4>\n<p>实验发现，“创建一个 offscreen cell ”是非常讲究的：</p>\n<ul>\n<li>如果使用 <code>[tableView dequeueReusableCellWithIdentifier:CellIdentifier atIndexPath:indexPath]</code> 来获得一个 cell ，会造成内存的泄漏，因为上面这个方法在调用之前会先调用 heightForRowAtIndexPath 这个方法本身，有点像循环引用的概念。</li>\n<li>直接用 <code>[[CustomCell alloc] init]</code> 来创建一个 cell 呢？如果使用的是 xib 或者纯代码的方式来创建布局的，那么当然没问题，不过千万不要忘了，在 VC 的某个地方调用一个 tableView 的 <code>registerClass:forCellReuseIdentifier:</code> 方法，把这个 CustomCell 给注册一下，否则会拿不到 cell 对应的属性。</li>\n<li>对于 Storyboard 来说，因为 CustomCell 是直接放在 tableView 里面的，IB 已经帮你完成了这一切，所以不需要 registerClass 。如果你执意要注册一下的话，不仅没有任何好处，反而会破坏了 IB 的和谐，导致 <code>tableView:cellForRowAtIndexPath:</code> 里面的 dequeue 方法无法返回一个正确的 cell。</li>\n</ul>\n<p>综上所述，用 Storyboard 就没有办法完成“创建一个 offscreen cell ”这一步了么？非也。\nTableView 还有一个方法叫 <code>[dequeueReusableCellWithIdentifier:]</code> ，注意到它没有了 indexPath 这个参数，所以它不会去调用 <code>tableView:heightForRowAtIndexPath:</code> ，这给我们提供了一线希望。于是，完整的代码是这样的：\n<img src=\"/uploads/using-autolayout-in-uitableviewcells/offscreen-cell-code.png\" alt=\"offscreen-cell-code\"></p>\n<p>这里用到了 static 和 dispatch_once 来使得这个 offscreen cell 只需要被创建一次，然后就可以循环利用了，环保？</p>\n<h4>填充数据</h4>\n<p>这里又是常规的填充数据，再啰嗦一次：如果使用了子类化 UILabel，那么这一步做的事会比看起来强大得多。不过，目前为止，这里看起来也只是填充一下数据而已。</p>\n<h4>计算高度</h4>\n<p>这里我们要用到 cell.contentView 里一个很强大的方法：<code>[systemLayoutSizeFittingSize:]</code>，后面跟的参数有两个可选项： <code>UILayoutFittingCompressedSize</code> 和 <code>UILayoutFittingExpandSize</code> ，前者会得到满足所有约束的最小 size ，后者得到的是最大 size 。</p>\n<p>这个方法看似方便，但也是因为我们前面做了许许多多的铺路：我们设置了贯通上下的约束，让 cell 能知道自己的内容总共有多高；我们设置了 UILabel 的 preferredMaxLayoutWidth ，让它们知道内容太多的时候要往下排列，等等等等。</p>\n<p>在调用这个方法之前，为了保险起见，还是要让 cell 自己适当排列一下自己的 subviews ，完整代码如下：\n<img src=\"/uploads/using-autolayout-in-uitableviewcells/return-height-code.png\" alt=\"return-height-code\">\n最后的<code>+1</code>只是为了让 cell 之间有 1pt 的空间容纳 separator。</p>\n<h2>写在最后</h2>\n<p>到这里，一个可以自适应内容高度的 cell 就已经做好了。虽然整篇文章看起来挺长，但是实际写起来代码量也并不大。</p>\n<p>其实如果还是觉得麻烦的话，让应用直接支持 iOS 8 以上不就好了:)</p>\n","excerpt":"<p>UITableViewCell 自适应内容高度已经是一个老生常谈的问题了，网络上也随处可以找到相关的资料。从 iOS 8 开始，强大的 AutoLayout 甚至已经可以直接接管 Cell 高度的计算，于是这一话题也就慢慢淡出了人们的视野，包括我...\n最近整理笔记的时候发现了这篇文章，想了想还是把它弄到新博客上来了。这篇文章是做毕业设计的时候（2014）总结下来的，当时因为要兼容到 iOS 7 ，所以用的都是比较原始的方法，不过在那个时候用起来还是比较顺手的（只是对比起 iOS 8 的用法，那真叫一个酸爽）。随着 iOS 后面的版本号越来越大，兼容 iOS 7 的应用应该也不多了，现在把它搬到这上面来，主要是为了记录以往走过的路，这些知识或许再也用不上，但积累它们的过程还是非常值得保留的。<s>另一个原因是为了扩充新博客的文章数目。</s>（喂！）</p>","more":"<h2>告诉我需求！</h2>\n<p>文中的界面制作使用的是 Storyboard，也会略微对比使用 xib 和纯代码的情况。</p>\n<p>首先假设这么一种情况，我们的 UITableViewCell 里面只使用到一种布局：\n<img src=\"/uploads/using-autolayout-in-uitableviewcells/cell-ui.png\" alt=\"cell-UI\">\n其中， State 只显示一行； Name 最多只能显示3行，字体大小不改变； Additional 可以显示任意多行，字体大小不改变。\n如果 cell 的布局变化比较大，比如说文字下面可能还有图片，4张图片和9张图片的布局要不同，那么还是建议把相去甚远的几种布局分别设计成几个不同的 cell，用 Cell Identifier 来区分彼此，然后再分别对每一个 cell 进行自适应内容高度的处理。</p>\n<h2>最喜欢IB了 - 约束设置</h2>\n<p>既然使用的是 Storyboard，那么一切的约束当然都是在 Storyboard 里面手动进行。\n想要让 cell 根据内容自动调整高度，一个极其重要也似乎是唯一的原则是：约束自上而下贯通整个 contentView。</p>\n<p>还是拿上面的截图做例子：</p>\n<ol>\n<li>State 必须要有一个 Top Space to: Superview，这个 Superview 应该是 cell 的 contentView 而不是 cell 本身。</li>\n<li>Name 要有一个 Top Space to: State，而这个 constant 是多少就可以随意了，它的作用主要是把二者的垂直空间连起来，怎么连、连多长都是看心情的事。</li>\n<li>Additional 除了要有一个 Top Space To: Name 之外，还需要有一个 Bottom Space To: Superview（这个也是 contentView）。</li>\n</ol>\n<p>其实，如果将旁边的数字 1 连到了 contentView 的 top 上，再把 State 跟数字 1 的 center Y 等同一下，也可以达到同样的效果。只是如果使用上面的构建方法，数字 1 就可以自己一边玩儿去了，因为三个 UILabel 已经完成了“确定 cell 所需高度”的关键任务。</p>\n<h2>Write the code, change the world!</h2>\n<p>下面将分别针对 UITableView 中需要进行修改的不同几处分开来进行说明。</p>\n<h3>主角 - CustomCell.m</h3>\n<p>相对来说最忙的应该是 CustomCell 这个自定义类了，所以放到最前面来说。\n在这个地方，需要关注的其实也只有两件事：</p>\n<ol>\n<li>为 cell 填充内容。</li>\n<li>layoutSubviews。</li>\n</ol>\n<h4>填充内容</h4>\n<p>其实就是属性的设置而已，但是需要注意的是，对于 UILabel 来说，我们想要看到的是，当显示的内容很多的时候，它可以有一个确定的宽度，然后多出来的内容自动往下接着排列下去。比较好的办法是，继承 UILabel，然后在子类中自己实现。这种做法也不麻烦，放到后面再说，现在我们这里就只是简单的设置几个 text 。</p>\n<blockquote>\n<p>代码呢？</p>\n</blockquote>\n<p>这么简单的赋值代码，我不贴！我不贴！</p>\n<h4>layoutSubviews</h4>\n<p>如果没有用继承 UILabel 的那套方案，那么这一步就是必须的，否则就是多余的。这里还是用到了继承的方案。\n我们需要重写 cell 的 layoutSubviews 方法，并让它为我们的 UILabel 设定一些规矩：\n<img src=\"/uploads/using-autolayout-in-uitableviewcells/layoutSubviews-code.png\" alt=\"layoutSubviews-code\">\n代码非常简单，因为当运行到这里的时候，AutoLayout 已经帮我们处理好了一大堆布局的问题，我们只需要告诉 UILabel ，我想要你显示多宽就可以了。</p>\n<h3>主角诞生的地方 - cellForRowAtIndexPath</h3>\n<p>除了常规的获取和配置 cell 之外，我们最好在最后面补上两句简短的代码：\n<img src=\"/uploads/using-autolayout-in-uitableviewcells/cellForRowAtIndexPath-code.png\" alt=\"cellForRowAtIndexPath-code\">\n这两句的作用是告诉我们能者多劳的 cell，如果你发现自己的约束改变了，那么就马上更新一下自己。不写这两句问题也不大，只是为了防止某些特殊情况下 cell 的显示异常。</p>\n<h3>到底要我长多高你才满意？！ - heightForRowAtIndexPath</h3>\n<p>最关键的地方来了，告诉 tableView 每个 cell 到底该是多高。这里有三个关键步骤：</p>\n<ol>\n<li>创建一个offscreen cell。</li>\n<li>模拟真实的cell填充数据。</li>\n<li>计算出这个offscreen cell的高度。</li>\n</ol>\n<p>实际上，我们要做的就是制作一个和当前位置需要显示的 cell 一模一样但却不会显示出来的 cell （好拗口），然后告诉 delegate 这个 cell 的高度即可。</p>\n<h4>Offscreen Cell</h4>\n<p>实验发现，“创建一个 offscreen cell ”是非常讲究的：</p>\n<ul>\n<li>如果使用 <code>[tableView dequeueReusableCellWithIdentifier:CellIdentifier atIndexPath:indexPath]</code> 来获得一个 cell ，会造成内存的泄漏，因为上面这个方法在调用之前会先调用 heightForRowAtIndexPath 这个方法本身，有点像循环引用的概念。</li>\n<li>直接用 <code>[[CustomCell alloc] init]</code> 来创建一个 cell 呢？如果使用的是 xib 或者纯代码的方式来创建布局的，那么当然没问题，不过千万不要忘了，在 VC 的某个地方调用一个 tableView 的 <code>registerClass:forCellReuseIdentifier:</code> 方法，把这个 CustomCell 给注册一下，否则会拿不到 cell 对应的属性。</li>\n<li>对于 Storyboard 来说，因为 CustomCell 是直接放在 tableView 里面的，IB 已经帮你完成了这一切，所以不需要 registerClass 。如果你执意要注册一下的话，不仅没有任何好处，反而会破坏了 IB 的和谐，导致 <code>tableView:cellForRowAtIndexPath:</code> 里面的 dequeue 方法无法返回一个正确的 cell。</li>\n</ul>\n<p>综上所述，用 Storyboard 就没有办法完成“创建一个 offscreen cell ”这一步了么？非也。\nTableView 还有一个方法叫 <code>[dequeueReusableCellWithIdentifier:]</code> ，注意到它没有了 indexPath 这个参数，所以它不会去调用 <code>tableView:heightForRowAtIndexPath:</code> ，这给我们提供了一线希望。于是，完整的代码是这样的：\n<img src=\"/uploads/using-autolayout-in-uitableviewcells/offscreen-cell-code.png\" alt=\"offscreen-cell-code\"></p>\n<p>这里用到了 static 和 dispatch_once 来使得这个 offscreen cell 只需要被创建一次，然后就可以循环利用了，环保？</p>\n<h4>填充数据</h4>\n<p>这里又是常规的填充数据，再啰嗦一次：如果使用了子类化 UILabel，那么这一步做的事会比看起来强大得多。不过，目前为止，这里看起来也只是填充一下数据而已。</p>\n<h4>计算高度</h4>\n<p>这里我们要用到 cell.contentView 里一个很强大的方法：<code>[systemLayoutSizeFittingSize:]</code>，后面跟的参数有两个可选项： <code>UILayoutFittingCompressedSize</code> 和 <code>UILayoutFittingExpandSize</code> ，前者会得到满足所有约束的最小 size ，后者得到的是最大 size 。</p>\n<p>这个方法看似方便，但也是因为我们前面做了许许多多的铺路：我们设置了贯通上下的约束，让 cell 能知道自己的内容总共有多高；我们设置了 UILabel 的 preferredMaxLayoutWidth ，让它们知道内容太多的时候要往下排列，等等等等。</p>\n<p>在调用这个方法之前，为了保险起见，还是要让 cell 自己适当排列一下自己的 subviews ，完整代码如下：\n<img src=\"/uploads/using-autolayout-in-uitableviewcells/return-height-code.png\" alt=\"return-height-code\">\n最后的<code>+1</code>只是为了让 cell 之间有 1pt 的空间容纳 separator。</p>\n<h2>写在最后</h2>\n<p>到这里，一个可以自适应内容高度的 cell 就已经做好了。虽然整篇文章看起来挺长，但是实际写起来代码量也并不大。</p>\n<p>其实如果还是觉得麻烦的话，让应用直接支持 iOS 8 以上不就好了:)</p>"},{"title":"移动应用消息推送的准备工作","date":"2016-06-06T01:47:34.000Z","_content":"每个移动应用开发者都会幻想自己的 App 被成千上万人每天不断地使用着，然而现实总是冰冷的：用户们总是会有意无意地把你的 App 关掉，并且有意无意地将它们晾在某个角落里。\n然而聪明的程序员们总有各种办法引起用户们的注意，而消息推送（ Push Notifications ）无疑是这些办法中最直接了当的一种。\n\n<!-- more -->\n\n说了那么多，就是为了讲讲移动应用上常用的消息推送的**准备工作（不涉及代码）** ，内容将会涵盖 iOS 和 Android 两个平台。（你说 Win... 什么来着？）因为这方面做的工作实在算不上多，所以难免有错误和纰漏，欢迎大家提出来交流和讨论。\n\n## 写在开头\n一听到要实现消息推送机制，首先会想到的应该是对服务器的需求了。想要定制化程度更高的推送机制，当然是要有自己的服务器比较稳妥，但在某些追求快捷方便的情况下，服务器倒也不是必要。\n\n对于追求开发速度的情况，已经有许多非常优秀的第三方服务商[^1]可以提供跨平台的解决方案，你压根就不需要考虑服务器的事情，甚至都不需要头疼集成的问题，因为这些产品的文档上都已经说明得很详细了。\n\n所以，本文要提到的将是 iOS 和 Android 两方自家的推送服务。\n\n## 两家的区别\n对于生态环境封闭的 iOS 来说，想要推送消息就必须走苹果的服务器。你需要从自己的服务器向苹果的推送服务器发起推送请求，再由它替你将消息推向*用户的设备*。整个过程中，你自己的服务器是完全接触不到用户设备的。\n\n而对于开放的 Android，虽然该 Google 有提供官方的服务，但你完全可以自己搭建一个推送服务器，将消息直接从你自己的服务器推送到*你自己的 App* 上。\n\n注意上面两段文字中推送目标的差异：\n\n* iOS 的推送服务器只是负责把消息推送到设备。每台 iOS 设备都有一个类似 IM 的程序跑在后台，统一接收来自服务器的推送，再分派到对应的 App 上去。\n* Android 的推送服务通常是把消息直接推送到应用。每个需要接收推送的应用都会跑一个常驻后台的消息接收器，从这个方面看，Android 的设备会比iOS 设备稍微更耗电一些。\n\n## iOS\n想要在 iOS 系统中完成一次推送，就必须要借助 APNs[^2] 的力量。这一步是无论如何都绕不开的，所以市面上所有的第三方 iOS 推送服务都相当于是在官方的渠道上封装了一层，不过这比起自己架设服务器来说还是便捷了不少。\n\n于是，各种配置还是必不可少的，区别只在最后生成的证书是你自己管还是让第三方托管。那么具体需要做些什么呢？\n\n### Enabling Push Notification Service\n这一步在 Xcode 中操作非常简单，就只需要两步：\n\n1. 在 Xcode 应用设置的 General 标签栏下设置 App 的 Bundle Identifier\n2. 在 Capabilities 标签栏下打开消息推送的开关\n![push-off](/uploads/push-notification-preparation/push-off.jpg)￼\n\n等它加载一会，成功后会变成这个样子：\n![push-on](/uploads/push-notification-preparation/push-on.jpg)\n\n这是为了告诉苹果：“我这个 ID 对应的 App 是要接收消息推送的”。\n\n### SSL Certificate\n完成了上面那一步之后，去到 Member Center 里找到刚刚填的那个 App ID，会看到下面 Push Notifications 的状态是两个黄黄的 \"Configurable\"，那说明现在已经万事俱备，只欠证书啦！\n\n点编辑进去，果真如此：\n![apple-push-notification](/uploads/push-notification-preparation/apple-push-notification.jpg)\n\n如果是在开发环境下，点 Development SSL Certificate 里面的 \"Create Certificate...\" 会有教程教你怎么申请自己的 CSR 文件，其实就是下面这张图这里：\n![request-csr](/uploads/push-notification-preparation/request-csr.jpg)\n\n在弹出窗口的 \"Request is\" 后面选 \"Saved to disk\"，然后就可以在指定位置找到一个 \".certSigningRequest\" 文件，把它上传到刚刚的网页上就可以了。\n\n传好之后点击 \"Generate\" 就可以生成属于你的 SSL 证书。把它下载下来，双击安装，然后就可以在 Keychain Access 里面找到对应的 Push Services 证书，在开发的过程中，Xcode会自动找到这里的证书并打包到对应的 App 里面去。\n\n### 小结\n如果使用的是第三方的服务，在生成了 SSL 证书之后，通常还需要将它的私钥导出为一个 .p12 后缀的文件，上传到第三方的服务器上。这就相当于授权了第三方使用你的身份去发推送消息了。如果你自己搭建了服务器，那就还需要将 .p12 文件转为 .pem 文件才能使用。这些都是后话了。\n\nP.S. 在应用要发布之前，还需要再走一遍上面的证书申请流程，不过这次要申请的是 Production SSL Certificate。\n\n## Android\n得益于其开放的生态环境，对比于 iOS 端，Android 这边几乎看不到什么证书相关的操作。\n\n类似于 APNs，Android 也有一套推送服务，叫 FCM[^3]。它的强大之处在于：它还提供了对 iOS 设备的推送服务。如果想要选择一个有背景的、可媲美官方可靠性的（人家本来就是 Google 官方...）第三方推送服务商，FCM 绝对是一个不错的选择。\n\nGoogle 已经把 FCM 很好地封装成 SDK 了，再加上已经不需要考虑证书的问题，你要做的就只是在网页上把 FCM 配置好，并把它的 SDK 下载下来，放到项目中。\n\n> 可以参考 [Set Up a Firebase Cloud Messaging Client App on Android\n](https://firebase.google.com/docs/cloud-messaging/android/client#set-up-firebase-and-the-fcm-sdk)和 [Add Firebase to your Android Project](https://firebase.google.com/docs/android/setup#prerequisites)。\n\n## 写在结尾\n没想到抛开了证书问题，Android 的准备工作就可以浓缩到一个小节里面了（虽然那两个网页也够看一会了），iOS可是洋洋洒洒分了三个部分呢。\n上面也只是介绍了开发消息推送的前期准备工作，做完这些之后才是我们程序员老本行的开始。\n\n## 参考资料\n* [Push Notifications Tutorial: Getting Started](https://www.raywenderlich.com/123862/push-notifications-tutorial)\n* [About Local and Remote Notifications](https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/Introduction.html)\n* [Firebase](https://firebase.google.com/)\n\n[^1]: 国外： [Parse](https://www.parse.com/)、[FCM（原来的 GCM ）](https://firebase.google.com/)；国内： [极光推送（ JPush ）](https://www.jpush.cn/)、 [个推](http://www.getui.com/)\n[^2]: 即 [Apple Push Notification service](https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html)\n[^3]: 即 [Firebase Cloud Messaging](https://firebase.google.com/docs/cloud-messaging/)，前身是 Google Cloud Messaging ( GCM )\n","source":"_posts/push-notification-preparation.md","raw":"---\ntitle: 移动应用消息推送的准备工作\ndate: 2016-06-06 09:47:34\ntags:\n- iOS\n- Android\n---\n每个移动应用开发者都会幻想自己的 App 被成千上万人每天不断地使用着，然而现实总是冰冷的：用户们总是会有意无意地把你的 App 关掉，并且有意无意地将它们晾在某个角落里。\n然而聪明的程序员们总有各种办法引起用户们的注意，而消息推送（ Push Notifications ）无疑是这些办法中最直接了当的一种。\n\n<!-- more -->\n\n说了那么多，就是为了讲讲移动应用上常用的消息推送的**准备工作（不涉及代码）** ，内容将会涵盖 iOS 和 Android 两个平台。（你说 Win... 什么来着？）因为这方面做的工作实在算不上多，所以难免有错误和纰漏，欢迎大家提出来交流和讨论。\n\n## 写在开头\n一听到要实现消息推送机制，首先会想到的应该是对服务器的需求了。想要定制化程度更高的推送机制，当然是要有自己的服务器比较稳妥，但在某些追求快捷方便的情况下，服务器倒也不是必要。\n\n对于追求开发速度的情况，已经有许多非常优秀的第三方服务商[^1]可以提供跨平台的解决方案，你压根就不需要考虑服务器的事情，甚至都不需要头疼集成的问题，因为这些产品的文档上都已经说明得很详细了。\n\n所以，本文要提到的将是 iOS 和 Android 两方自家的推送服务。\n\n## 两家的区别\n对于生态环境封闭的 iOS 来说，想要推送消息就必须走苹果的服务器。你需要从自己的服务器向苹果的推送服务器发起推送请求，再由它替你将消息推向*用户的设备*。整个过程中，你自己的服务器是完全接触不到用户设备的。\n\n而对于开放的 Android，虽然该 Google 有提供官方的服务，但你完全可以自己搭建一个推送服务器，将消息直接从你自己的服务器推送到*你自己的 App* 上。\n\n注意上面两段文字中推送目标的差异：\n\n* iOS 的推送服务器只是负责把消息推送到设备。每台 iOS 设备都有一个类似 IM 的程序跑在后台，统一接收来自服务器的推送，再分派到对应的 App 上去。\n* Android 的推送服务通常是把消息直接推送到应用。每个需要接收推送的应用都会跑一个常驻后台的消息接收器，从这个方面看，Android 的设备会比iOS 设备稍微更耗电一些。\n\n## iOS\n想要在 iOS 系统中完成一次推送，就必须要借助 APNs[^2] 的力量。这一步是无论如何都绕不开的，所以市面上所有的第三方 iOS 推送服务都相当于是在官方的渠道上封装了一层，不过这比起自己架设服务器来说还是便捷了不少。\n\n于是，各种配置还是必不可少的，区别只在最后生成的证书是你自己管还是让第三方托管。那么具体需要做些什么呢？\n\n### Enabling Push Notification Service\n这一步在 Xcode 中操作非常简单，就只需要两步：\n\n1. 在 Xcode 应用设置的 General 标签栏下设置 App 的 Bundle Identifier\n2. 在 Capabilities 标签栏下打开消息推送的开关\n![push-off](/uploads/push-notification-preparation/push-off.jpg)￼\n\n等它加载一会，成功后会变成这个样子：\n![push-on](/uploads/push-notification-preparation/push-on.jpg)\n\n这是为了告诉苹果：“我这个 ID 对应的 App 是要接收消息推送的”。\n\n### SSL Certificate\n完成了上面那一步之后，去到 Member Center 里找到刚刚填的那个 App ID，会看到下面 Push Notifications 的状态是两个黄黄的 \"Configurable\"，那说明现在已经万事俱备，只欠证书啦！\n\n点编辑进去，果真如此：\n![apple-push-notification](/uploads/push-notification-preparation/apple-push-notification.jpg)\n\n如果是在开发环境下，点 Development SSL Certificate 里面的 \"Create Certificate...\" 会有教程教你怎么申请自己的 CSR 文件，其实就是下面这张图这里：\n![request-csr](/uploads/push-notification-preparation/request-csr.jpg)\n\n在弹出窗口的 \"Request is\" 后面选 \"Saved to disk\"，然后就可以在指定位置找到一个 \".certSigningRequest\" 文件，把它上传到刚刚的网页上就可以了。\n\n传好之后点击 \"Generate\" 就可以生成属于你的 SSL 证书。把它下载下来，双击安装，然后就可以在 Keychain Access 里面找到对应的 Push Services 证书，在开发的过程中，Xcode会自动找到这里的证书并打包到对应的 App 里面去。\n\n### 小结\n如果使用的是第三方的服务，在生成了 SSL 证书之后，通常还需要将它的私钥导出为一个 .p12 后缀的文件，上传到第三方的服务器上。这就相当于授权了第三方使用你的身份去发推送消息了。如果你自己搭建了服务器，那就还需要将 .p12 文件转为 .pem 文件才能使用。这些都是后话了。\n\nP.S. 在应用要发布之前，还需要再走一遍上面的证书申请流程，不过这次要申请的是 Production SSL Certificate。\n\n## Android\n得益于其开放的生态环境，对比于 iOS 端，Android 这边几乎看不到什么证书相关的操作。\n\n类似于 APNs，Android 也有一套推送服务，叫 FCM[^3]。它的强大之处在于：它还提供了对 iOS 设备的推送服务。如果想要选择一个有背景的、可媲美官方可靠性的（人家本来就是 Google 官方...）第三方推送服务商，FCM 绝对是一个不错的选择。\n\nGoogle 已经把 FCM 很好地封装成 SDK 了，再加上已经不需要考虑证书的问题，你要做的就只是在网页上把 FCM 配置好，并把它的 SDK 下载下来，放到项目中。\n\n> 可以参考 [Set Up a Firebase Cloud Messaging Client App on Android\n](https://firebase.google.com/docs/cloud-messaging/android/client#set-up-firebase-and-the-fcm-sdk)和 [Add Firebase to your Android Project](https://firebase.google.com/docs/android/setup#prerequisites)。\n\n## 写在结尾\n没想到抛开了证书问题，Android 的准备工作就可以浓缩到一个小节里面了（虽然那两个网页也够看一会了），iOS可是洋洋洒洒分了三个部分呢。\n上面也只是介绍了开发消息推送的前期准备工作，做完这些之后才是我们程序员老本行的开始。\n\n## 参考资料\n* [Push Notifications Tutorial: Getting Started](https://www.raywenderlich.com/123862/push-notifications-tutorial)\n* [About Local and Remote Notifications](https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/Introduction.html)\n* [Firebase](https://firebase.google.com/)\n\n[^1]: 国外： [Parse](https://www.parse.com/)、[FCM（原来的 GCM ）](https://firebase.google.com/)；国内： [极光推送（ JPush ）](https://www.jpush.cn/)、 [个推](http://www.getui.com/)\n[^2]: 即 [Apple Push Notification service](https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html)\n[^3]: 即 [Firebase Cloud Messaging](https://firebase.google.com/docs/cloud-messaging/)，前身是 Google Cloud Messaging ( GCM )\n","slug":"push-notification-preparation","published":1,"updated":"2016-06-06T02:35:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip56hb70000agr8f7cf9p59j","content":"<p>每个移动应用开发者都会幻想自己的 App 被成千上万人每天不断地使用着，然而现实总是冰冷的：用户们总是会有意无意地把你的 App 关掉，并且有意无意地将它们晾在某个角落里。\n然而聪明的程序员们总有各种办法引起用户们的注意，而消息推送（ Push Notifications ）无疑是这些办法中最直接了当的一种。</p>\n<a id=\"more\"></a>\n<p>说了那么多，就是为了讲讲移动应用上常用的消息推送的<strong>准备工作（不涉及代码）</strong> ，内容将会涵盖 iOS 和 Android 两个平台。（你说 Win... 什么来着？）因为这方面做的工作实在算不上多，所以难免有错误和纰漏，欢迎大家提出来交流和讨论。</p>\n<h2>写在开头</h2>\n<p>一听到要实现消息推送机制，首先会想到的应该是对服务器的需求了。想要定制化程度更高的推送机制，当然是要有自己的服务器比较稳妥，但在某些追求快捷方便的情况下，服务器倒也不是必要。</p>\n<p>对于追求开发速度的情况，已经有许多非常优秀的第三方服务商<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>可以提供跨平台的解决方案，你压根就不需要考虑服务器的事情，甚至都不需要头疼集成的问题，因为这些产品的文档上都已经说明得很详细了。</p>\n<p>所以，本文要提到的将是 iOS 和 Android 两方自家的推送服务。</p>\n<h2>两家的区别</h2>\n<p>对于生态环境封闭的 iOS 来说，想要推送消息就必须走苹果的服务器。你需要从自己的服务器向苹果的推送服务器发起推送请求，再由它替你将消息推向<em>用户的设备</em>。整个过程中，你自己的服务器是完全接触不到用户设备的。</p>\n<p>而对于开放的 Android，虽然该 Google 有提供官方的服务，但你完全可以自己搭建一个推送服务器，将消息直接从你自己的服务器推送到<em>你自己的 App</em> 上。</p>\n<p>注意上面两段文字中推送目标的差异：</p>\n<ul>\n<li>iOS 的推送服务器只是负责把消息推送到设备。每台 iOS 设备都有一个类似 IM 的程序跑在后台，统一接收来自服务器的推送，再分派到对应的 App 上去。</li>\n<li>Android 的推送服务通常是把消息直接推送到应用。每个需要接收推送的应用都会跑一个常驻后台的消息接收器，从这个方面看，Android 的设备会比iOS 设备稍微更耗电一些。</li>\n</ul>\n<h2>iOS</h2>\n<p>想要在 iOS 系统中完成一次推送，就必须要借助 APNs<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup> 的力量。这一步是无论如何都绕不开的，所以市面上所有的第三方 iOS 推送服务都相当于是在官方的渠道上封装了一层，不过这比起自己架设服务器来说还是便捷了不少。</p>\n<p>于是，各种配置还是必不可少的，区别只在最后生成的证书是你自己管还是让第三方托管。那么具体需要做些什么呢？</p>\n<h3>Enabling Push Notification Service</h3>\n<p>这一步在 Xcode 中操作非常简单，就只需要两步：</p>\n<ol>\n<li>在 Xcode 应用设置的 General 标签栏下设置 App 的 Bundle Identifier</li>\n<li>在 Capabilities 标签栏下打开消息推送的开关\n<img src=\"/uploads/push-notification-preparation/push-off.jpg\" alt=\"push-off\">￼</li>\n</ol>\n<p>等它加载一会，成功后会变成这个样子：\n<img src=\"/uploads/push-notification-preparation/push-on.jpg\" alt=\"push-on\"></p>\n<p>这是为了告诉苹果：“我这个 ID 对应的 App 是要接收消息推送的”。</p>\n<h3>SSL Certificate</h3>\n<p>完成了上面那一步之后，去到 Member Center 里找到刚刚填的那个 App ID，会看到下面 Push Notifications 的状态是两个黄黄的 &quot;Configurable&quot;，那说明现在已经万事俱备，只欠证书啦！</p>\n<p>点编辑进去，果真如此：\n<img src=\"/uploads/push-notification-preparation/apple-push-notification.jpg\" alt=\"apple-push-notification\"></p>\n<p>如果是在开发环境下，点 Development SSL Certificate 里面的 &quot;Create Certificate...&quot; 会有教程教你怎么申请自己的 CSR 文件，其实就是下面这张图这里：\n<img src=\"/uploads/push-notification-preparation/request-csr.jpg\" alt=\"request-csr\"></p>\n<p>在弹出窗口的 &quot;Request is&quot; 后面选 &quot;Saved to disk&quot;，然后就可以在指定位置找到一个 &quot;.certSigningRequest&quot; 文件，把它上传到刚刚的网页上就可以了。</p>\n<p>传好之后点击 &quot;Generate&quot; 就可以生成属于你的 SSL 证书。把它下载下来，双击安装，然后就可以在 Keychain Access 里面找到对应的 Push Services 证书，在开发的过程中，Xcode会自动找到这里的证书并打包到对应的 App 里面去。</p>\n<h3>小结</h3>\n<p>如果使用的是第三方的服务，在生成了 SSL 证书之后，通常还需要将它的私钥导出为一个 .p12 后缀的文件，上传到第三方的服务器上。这就相当于授权了第三方使用你的身份去发推送消息了。如果你自己搭建了服务器，那就还需要将 .p12 文件转为 .pem 文件才能使用。这些都是后话了。</p>\n<p>P.S. 在应用要发布之前，还需要再走一遍上面的证书申请流程，不过这次要申请的是 Production SSL Certificate。</p>\n<h2>Android</h2>\n<p>得益于其开放的生态环境，对比于 iOS 端，Android 这边几乎看不到什么证书相关的操作。</p>\n<p>类似于 APNs，Android 也有一套推送服务，叫 FCM<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>。它的强大之处在于：它还提供了对 iOS 设备的推送服务。如果想要选择一个有背景的、可媲美官方可靠性的（人家本来就是 Google 官方...）第三方推送服务商，FCM 绝对是一个不错的选择。</p>\n<p>Google 已经把 FCM 很好地封装成 SDK 了，再加上已经不需要考虑证书的问题，你要做的就只是在网页上把 FCM 配置好，并把它的 SDK 下载下来，放到项目中。</p>\n<blockquote>\n<p>可以参考 <a href=\"https://firebase.google.com/docs/cloud-messaging/android/client#set-up-firebase-and-the-fcm-sdk\" target=\"_blank\" rel=\"external\">Set Up a Firebase Cloud Messaging Client App on Android\n</a>和 <a href=\"https://firebase.google.com/docs/android/setup#prerequisites\" target=\"_blank\" rel=\"external\">Add Firebase to your Android Project</a>。</p>\n</blockquote>\n<h2>写在结尾</h2>\n<p>没想到抛开了证书问题，Android 的准备工作就可以浓缩到一个小节里面了（虽然那两个网页也够看一会了），iOS可是洋洋洒洒分了三个部分呢。\n上面也只是介绍了开发消息推送的前期准备工作，做完这些之后才是我们程序员老本行的开始。</p>\n<h2>参考资料</h2>\n<ul>\n<li><a href=\"https://www.raywenderlich.com/123862/push-notifications-tutorial\" target=\"_blank\" rel=\"external\">Push Notifications Tutorial: Getting Started</a></li>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/Introduction.html\" target=\"_blank\" rel=\"external\">About Local and Remote Notifications</a></li>\n<li><a href=\"https://firebase.google.com/\" target=\"_blank\" rel=\"external\">Firebase</a></li>\n</ul>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>国外： <a href=\"https://www.parse.com/\" target=\"_blank\" rel=\"external\">Parse</a>、<a href=\"https://firebase.google.com/\" target=\"_blank\" rel=\"external\">FCM（原来的 GCM ）</a>；国内： <a href=\"https://www.jpush.cn/\" target=\"_blank\" rel=\"external\">极光推送（ JPush ）</a>、 <a href=\"http://www.getui.com/\" target=\"_blank\" rel=\"external\">个推</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>即 <a href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html\" target=\"_blank\" rel=\"external\">Apple Push Notification service</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>即 <a href=\"https://firebase.google.com/docs/cloud-messaging/\" target=\"_blank\" rel=\"external\">Firebase Cloud Messaging</a>，前身是 Google Cloud Messaging ( GCM ) <a href=\"#fnref3\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n","excerpt":"<p>每个移动应用开发者都会幻想自己的 App 被成千上万人每天不断地使用着，然而现实总是冰冷的：用户们总是会有意无意地把你的 App 关掉，并且有意无意地将它们晾在某个角落里。\n然而聪明的程序员们总有各种办法引起用户们的注意，而消息推送（ Push Notifications ）无疑是这些办法中最直接了当的一种。</p>","more":"<p>说了那么多，就是为了讲讲移动应用上常用的消息推送的<strong>准备工作（不涉及代码）</strong> ，内容将会涵盖 iOS 和 Android 两个平台。（你说 Win... 什么来着？）因为这方面做的工作实在算不上多，所以难免有错误和纰漏，欢迎大家提出来交流和讨论。</p>\n<h2>写在开头</h2>\n<p>一听到要实现消息推送机制，首先会想到的应该是对服务器的需求了。想要定制化程度更高的推送机制，当然是要有自己的服务器比较稳妥，但在某些追求快捷方便的情况下，服务器倒也不是必要。</p>\n<p>对于追求开发速度的情况，已经有许多非常优秀的第三方服务商<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>可以提供跨平台的解决方案，你压根就不需要考虑服务器的事情，甚至都不需要头疼集成的问题，因为这些产品的文档上都已经说明得很详细了。</p>\n<p>所以，本文要提到的将是 iOS 和 Android 两方自家的推送服务。</p>\n<h2>两家的区别</h2>\n<p>对于生态环境封闭的 iOS 来说，想要推送消息就必须走苹果的服务器。你需要从自己的服务器向苹果的推送服务器发起推送请求，再由它替你将消息推向<em>用户的设备</em>。整个过程中，你自己的服务器是完全接触不到用户设备的。</p>\n<p>而对于开放的 Android，虽然该 Google 有提供官方的服务，但你完全可以自己搭建一个推送服务器，将消息直接从你自己的服务器推送到<em>你自己的 App</em> 上。</p>\n<p>注意上面两段文字中推送目标的差异：</p>\n<ul>\n<li>iOS 的推送服务器只是负责把消息推送到设备。每台 iOS 设备都有一个类似 IM 的程序跑在后台，统一接收来自服务器的推送，再分派到对应的 App 上去。</li>\n<li>Android 的推送服务通常是把消息直接推送到应用。每个需要接收推送的应用都会跑一个常驻后台的消息接收器，从这个方面看，Android 的设备会比iOS 设备稍微更耗电一些。</li>\n</ul>\n<h2>iOS</h2>\n<p>想要在 iOS 系统中完成一次推送，就必须要借助 APNs<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup> 的力量。这一步是无论如何都绕不开的，所以市面上所有的第三方 iOS 推送服务都相当于是在官方的渠道上封装了一层，不过这比起自己架设服务器来说还是便捷了不少。</p>\n<p>于是，各种配置还是必不可少的，区别只在最后生成的证书是你自己管还是让第三方托管。那么具体需要做些什么呢？</p>\n<h3>Enabling Push Notification Service</h3>\n<p>这一步在 Xcode 中操作非常简单，就只需要两步：</p>\n<ol>\n<li>在 Xcode 应用设置的 General 标签栏下设置 App 的 Bundle Identifier</li>\n<li>在 Capabilities 标签栏下打开消息推送的开关\n<img src=\"/uploads/push-notification-preparation/push-off.jpg\" alt=\"push-off\">￼</li>\n</ol>\n<p>等它加载一会，成功后会变成这个样子：\n<img src=\"/uploads/push-notification-preparation/push-on.jpg\" alt=\"push-on\"></p>\n<p>这是为了告诉苹果：“我这个 ID 对应的 App 是要接收消息推送的”。</p>\n<h3>SSL Certificate</h3>\n<p>完成了上面那一步之后，去到 Member Center 里找到刚刚填的那个 App ID，会看到下面 Push Notifications 的状态是两个黄黄的 &quot;Configurable&quot;，那说明现在已经万事俱备，只欠证书啦！</p>\n<p>点编辑进去，果真如此：\n<img src=\"/uploads/push-notification-preparation/apple-push-notification.jpg\" alt=\"apple-push-notification\"></p>\n<p>如果是在开发环境下，点 Development SSL Certificate 里面的 &quot;Create Certificate...&quot; 会有教程教你怎么申请自己的 CSR 文件，其实就是下面这张图这里：\n<img src=\"/uploads/push-notification-preparation/request-csr.jpg\" alt=\"request-csr\"></p>\n<p>在弹出窗口的 &quot;Request is&quot; 后面选 &quot;Saved to disk&quot;，然后就可以在指定位置找到一个 &quot;.certSigningRequest&quot; 文件，把它上传到刚刚的网页上就可以了。</p>\n<p>传好之后点击 &quot;Generate&quot; 就可以生成属于你的 SSL 证书。把它下载下来，双击安装，然后就可以在 Keychain Access 里面找到对应的 Push Services 证书，在开发的过程中，Xcode会自动找到这里的证书并打包到对应的 App 里面去。</p>\n<h3>小结</h3>\n<p>如果使用的是第三方的服务，在生成了 SSL 证书之后，通常还需要将它的私钥导出为一个 .p12 后缀的文件，上传到第三方的服务器上。这就相当于授权了第三方使用你的身份去发推送消息了。如果你自己搭建了服务器，那就还需要将 .p12 文件转为 .pem 文件才能使用。这些都是后话了。</p>\n<p>P.S. 在应用要发布之前，还需要再走一遍上面的证书申请流程，不过这次要申请的是 Production SSL Certificate。</p>\n<h2>Android</h2>\n<p>得益于其开放的生态环境，对比于 iOS 端，Android 这边几乎看不到什么证书相关的操作。</p>\n<p>类似于 APNs，Android 也有一套推送服务，叫 FCM<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>。它的强大之处在于：它还提供了对 iOS 设备的推送服务。如果想要选择一个有背景的、可媲美官方可靠性的（人家本来就是 Google 官方...）第三方推送服务商，FCM 绝对是一个不错的选择。</p>\n<p>Google 已经把 FCM 很好地封装成 SDK 了，再加上已经不需要考虑证书的问题，你要做的就只是在网页上把 FCM 配置好，并把它的 SDK 下载下来，放到项目中。</p>\n<blockquote>\n<p>可以参考 <a href=\"https://firebase.google.com/docs/cloud-messaging/android/client#set-up-firebase-and-the-fcm-sdk\">Set Up a Firebase Cloud Messaging Client App on Android\n</a>和 <a href=\"https://firebase.google.com/docs/android/setup#prerequisites\">Add Firebase to your Android Project</a>。</p>\n</blockquote>\n<h2>写在结尾</h2>\n<p>没想到抛开了证书问题，Android 的准备工作就可以浓缩到一个小节里面了（虽然那两个网页也够看一会了），iOS可是洋洋洒洒分了三个部分呢。\n上面也只是介绍了开发消息推送的前期准备工作，做完这些之后才是我们程序员老本行的开始。</p>\n<h2>参考资料</h2>\n<ul>\n<li><a href=\"https://www.raywenderlich.com/123862/push-notifications-tutorial\">Push Notifications Tutorial: Getting Started</a></li>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/Introduction.html\">About Local and Remote Notifications</a></li>\n<li><a href=\"https://firebase.google.com/\">Firebase</a></li>\n</ul>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\"  class=\"footnote-item\"><p>国外： <a href=\"https://www.parse.com/\">Parse</a>、<a href=\"https://firebase.google.com/\">FCM（原来的 GCM ）</a>；国内： <a href=\"https://www.jpush.cn/\">极光推送（ JPush ）</a>、 <a href=\"http://www.getui.com/\">个推</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\"  class=\"footnote-item\"><p>即 <a href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html\">Apple Push Notification service</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn3\"  class=\"footnote-item\"><p>即 <a href=\"https://firebase.google.com/docs/cloud-messaging/\">Firebase Cloud Messaging</a>，前身是 Google Cloud Messaging ( GCM ) <a href=\"#fnref3\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cip56hb6b0000gr8f82dkjt66","tag_id":"cip56hb6l0004gr8f9lxktcoj","_id":"cip56hb75000dgr8fuovau1wz"},{"post_id":"cip56hb6b0000gr8f82dkjt66","tag_id":"cip56hb6s0007gr8fxc1j1j6j","_id":"cip56hb75000egr8ftuhudp9j"},{"post_id":"cip56hb6b0000gr8f82dkjt66","tag_id":"cip56hb72000bgr8f1fi5le0n","_id":"cip56hb76000ggr8fqyq9nmq8"},{"post_id":"cip56hb6h0002gr8f9363o3q3","tag_id":"cip56hb74000cgr8fh5gwdu6k","_id":"cip56hb78000kgr8fcmscz05w"},{"post_id":"cip56hb6h0002gr8f9363o3q3","tag_id":"cip56hb76000fgr8fg1kf53k0","_id":"cip56hb78000lgr8fb7f6msof"},{"post_id":"cip56hb6h0002gr8f9363o3q3","tag_id":"cip56hb76000hgr8ff446pyt8","_id":"cip56hb79000ngr8fy16bmt83"},{"post_id":"cip56hb6h0002gr8f9363o3q3","tag_id":"cip56hb76000igr8f4elbcpzb","_id":"cip56hb79000ogr8f012m13no"},{"post_id":"cip56hb6n0005gr8fmbj5qi7d","tag_id":"cip56hb74000cgr8fh5gwdu6k","_id":"cip56hb7a000sgr8f86us5pzk"},{"post_id":"cip56hb6n0005gr8fmbj5qi7d","tag_id":"cip56hb76000fgr8fg1kf53k0","_id":"cip56hb7a000tgr8fo4zj6tmw"},{"post_id":"cip56hb6n0005gr8fmbj5qi7d","tag_id":"cip56hb79000pgr8flvn9lois","_id":"cip56hb7a000vgr8fnpqyb71r"},{"post_id":"cip56hb6n0005gr8fmbj5qi7d","tag_id":"cip56hb79000qgr8fpw79uv01","_id":"cip56hb7a000wgr8fbie6529v"},{"post_id":"cip56hb6q0006gr8f2dsknloy","tag_id":"cip56hb6l0004gr8f9lxktcoj","_id":"cip56hb7b000ygr8fsln9qfj2"},{"post_id":"cip56hb6q0006gr8f2dsknloy","tag_id":"cip56hb7a000rgr8f7nx5njcd","_id":"cip56hb7b000zgr8fp566t5sh"},{"post_id":"cip56hb6t0008gr8ftthi4qq0","tag_id":"cip56hb6l0004gr8f9lxktcoj","_id":"cip56hb7b0011gr8f34c3pe31"},{"post_id":"cip56hb6t0008gr8ftthi4qq0","tag_id":"cip56hb7a000ugr8fee9u0l3p","_id":"cip56hb7b0012gr8fpj3hhewb"},{"post_id":"cip56hb6v0009gr8fay07g30u","tag_id":"cip56hb6l0004gr8f9lxktcoj","_id":"cip56hb7c0014gr8f151q252i"},{"post_id":"cip56hb6v0009gr8fay07g30u","tag_id":"cip56hb7b000xgr8fty2gzhd5","_id":"cip56hb7c0015gr8f4vsdisrb"},{"post_id":"cip56hb6v0009gr8fay07g30u","tag_id":"cip56hb7b0010gr8fq1bu63l5","_id":"cip56hb7c0016gr8f20h6fz0v"},{"post_id":"cip56hb70000agr8f7cf9p59j","tag_id":"cip56hb6l0004gr8f9lxktcoj","_id":"cip56hb7c0017gr8fk8t88uow"},{"post_id":"cip56hb70000agr8f7cf9p59j","tag_id":"cip56hb7b0013gr8fdd53pd3o","_id":"cip56hb7d0018gr8fnch3rro1"}],"Tag":[{"name":"iOS","_id":"cip56hb6l0004gr8f9lxktcoj"},{"name":"Swift","_id":"cip56hb6s0007gr8fxc1j1j6j"},{"name":"CocoaPods","_id":"cip56hb72000bgr8f1fi5le0n"},{"name":"加解密","_id":"cip56hb74000cgr8fh5gwdu6k"},{"name":"安全","_id":"cip56hb76000fgr8fg1kf53k0"},{"name":"AES","_id":"cip56hb76000hgr8ff446pyt8"},{"name":"DES","_id":"cip56hb76000igr8f4elbcpzb"},{"name":"Hash","_id":"cip56hb79000pgr8flvn9lois"},{"name":"Salt","_id":"cip56hb79000qgr8fpw79uv01"},{"name":"Exif","_id":"cip56hb7a000rgr8f7nx5njcd"},{"name":"Core Data","_id":"cip56hb7a000ugr8fee9u0l3p"},{"name":"AutoLayout","_id":"cip56hb7b000xgr8fty2gzhd5"},{"name":"UITableViewCell","_id":"cip56hb7b0010gr8fq1bu63l5"},{"name":"Android","_id":"cip56hb7b0013gr8fdd53pd3o"}]}}